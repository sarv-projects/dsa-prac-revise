
# Table of Contents

## Section 1: Arrays & Hashing
- [Contains Duplicate [Must Do]](#1️⃣-contains-duplicate-must-do)
- [Valid Anagram](#2️⃣-valid-anagram)
- [Two Sum [Must Do]](#3️⃣-two-sum-must-do)
- [Group Anagrams [Must Do]](#4️⃣-group-anagrams-must-do)
- [Top K Frequent Elements [Must Do]](#5️⃣-top-k-frequent-elements-must-do)
- [Encode and Decode Strings](#6️⃣-encode-and-decode-strings)
- [Product of Array Except Self [Must Do]](#7️⃣-product-of-array-except-self-must-do)
- [Valid Sudoku [Must Do]](#8️⃣-valid-sudoku-must-do)
- [Longest Consecutive Sequence [Must Do]](#9️⃣-longest-consecutive-sequence-must-do)

## Section 2: Two Pointers
- [Valid Palindrome [Must Do]](#1️⃣-valid-palindrome-must-do)
- [Two Sum II – Input Array Is Sorted [Must Do]](#2️⃣-two-sum-ii--input-array-is-sorted-must-do)
- [3Sum [Must Do]](#3️⃣-3sum-must-do)
- [Container With Most Water [Must Do]](#4️⃣-container-with-most-water-must-do)
- [Trapping Rain Water [Must Do]](#5️⃣-trapping-rain-water-must-do)

## Section 3: Sliding Window
- [Best Time to Buy and Sell Stock [Must Do]](#1️⃣-best-time-to-buy-and-sell-stock-must-do)
- [Longest Substring Without Repeating Characters [Must Do]](#2️⃣-longest-substring-without-repeating-characters-must-do)
- [Longest Repeating Character Replacement [Must Do]](#3️⃣-longest-repeating-character-replacement-must-do)
- [Permutation in String [Must Do]](#4️⃣-permutation-in-string-must-do)
- [Minimum Window Substring [Must Do]](#5️⃣-minimum-window-substring-must-do)
- [Sliding Window Maximum [Must Do]](#6️⃣-sliding-window-maximum-must-do)


## Section 4: Stack

* [Valid Parentheses \[Must Do\]](#1️⃣-valid-parentheses-must-do)
* [Min Stack \[Must Do\]](#2️⃣-min-stack-must-do)
* [Evaluate Reverse Polish Notation \[Must Do\]](#3️⃣-evaluate-reverse-polish-notation-must-do)
* [Generate Parentheses \[Must Do\]](#4️⃣-generate-parentheses-must-do)
* [Daily Temperatures \[Must Do\]](#5️⃣-daily-temperatures-must-do)
* [Car Fleet](#6️⃣-car-fleet)
* [Largest Rectangle in Histogram \[Must Do\]](#7️⃣-largest-rectangle-in-histogram-must-do)

## Section 5: Binary Search

* [Binary Search \[Must Do\]](#1️⃣-binary-search-must-do)
* [Search a 2D Matrix \[Must Do\]](#2️⃣-search-a-2d-matrix-must-do)
* [Koko Eating Bananas \[Must Do\]](#3️⃣-koko-eating-bananas-must-do)
* [Find Minimum in Rotated Sorted Array \[Must Do\]](#4️⃣-find-minimum-in-rotated-sorted-array-must-do)
* [Search in Rotated Sorted Array \[Must Do\]](#5️⃣-search-in-rotated-sorted-array-must-do)
* [Time-Based Key Value Store \[Must Do\]](#6️⃣-time-based-key-value-store-must-do)

## Section 6: Greedy

* [Maximum Subarray \[Must Do\]](#1️⃣-maximum-subarray-must-do)
* [Jump Game \[Must Do\]](#2️⃣-jump-game-must-do)
* [Jump Game II \[Must Do\]](#3️⃣-jump-game-ii-must-do)
* [Gas Station \[Must Do\]](#4️⃣-gas-station-must-do)
* [Hand of Straights](#5️⃣-hand-of-straights)
* [Merge Triplets to Form Target Triplet](#6️⃣-merge-triplets-to-form-target-triplet)
* [Partition Labels](#7️⃣-partition-labels)
* [Valid Parenthesis String](#8️⃣-valid-parenthesis-string)

## Section 7: Intervals

* [Insert Interval \[Must Do\]](#1️⃣-insert-interval-must-do)
* [Merge Intervals \[Must Do\]](#2️⃣-merge-intervals-must-do)
* [Non-Overlapping Intervals \[Must Do\]](#3️⃣-non-overlapping-intervals-must-do)
* [Meeting Rooms](#4️⃣-meeting-rooms)
* [Meeting Rooms II \[Must Do\]](#5️⃣-meeting-rooms-ii-must-do)
* [Minimum Interval to Include Each Query](#6️⃣-minimum-interval-to-include-each-query)


## Section 8: Math & Geometry

* [Rotate Image $Must Do$](#1️⃣-rotate-image-must-do)
* [Spiral Matrix $Must Do$](#2️⃣-spiral-matrix-must-do)
* [Set Matrix Zeroes $Must Do$](#3️⃣-set-matrix-zeroes-must-do)
* [Happy Number $Must Do$](#4️⃣-happy-number-must-do)
* [Plus One $Must Do$](#5️⃣-plus-one-must-do)
* [Pow(x, n) $Must Do$](#6️⃣-powx-n-must-do)
* [Multiply Strings $Must Do$](#7️⃣-multiply-strings-must-do)
* [Detect Squares](#8️⃣-detect-squares)
* [Detect Triangles $Must Do$](#9️⃣-detect-triangles-must-do)

## Section 9: Bit Manipulation

* [Single Number $Must Do$](#1️⃣-single-number-must-do)
* [Number of 1 Bits $Must Do$](#2️⃣-number-of-1-bits-must-do)
* [Counting Bits $Must Do$](#3️⃣-counting-bits-must-do)
* [Reverse Bits $Must Do$](#4️⃣-reverse-bits-must-do)
* [Missing Number $Must Do$](#5️⃣-missing-number-must-do)
* [Sum of Two Integers $Must Do$](#6️⃣-sum-of-two-integers-must-do)
* [Reverse Integer $Must Do$](#7️⃣-reverse-integer-must-do)

## Section 10: Linked List

* [Reverse Linked List $Must Do$](#1️⃣-reverse-linked-list-must-do)
* [Merge Two Sorted Lists $Must Do$](#2️⃣-merge-two-sorted-lists-must-do)
* [Linked List Cycle $Must Do$](#3️⃣-linked-list-cycle-must-do)
* [Reorder List $Must Do$](#4️⃣-reorder-list-must-do)
* [Remove Nth Node From End $Must Do$](#5️⃣-remove-nth-node-from-end-must-do)
* [Copy List With Random Pointer $Must Do$](#6️⃣-copy-list-with-random-pointer-must-do)
* [Add Two Numbers $Must Do$](#7️⃣-add-two-numbers-must-do)
* [Find the Duplicate Number $Must Do$](#8️⃣-find-the-duplicate-number-must-do)
* [LRU Cache $Must Do$](#9️⃣-lru-cache-must-do)
* [Merge K Sorted Lists $Must Do$](#10️⃣-merge-k-sorted-lists-must-do)
* [Reverse Nodes in k-Group $Must Do$](#11️⃣-reverse-nodes-in-k-group-must-do)


## Section 11: Trees

* [Invert Binary Tree \$Must Do\$](#1️⃣-invert-binary-tree-must-do)
* [Maximum Depth of Binary Tree \$Must Do\$](#2️⃣-maximum-depth-of-binary-tree-must-do)
* [Diameter of Binary Tree \$Must Do\$](#3️⃣-diameter-of-binary-tree-must-do)
* [Balanced Binary Tree \$Must Do\$](#4️⃣-balanced-binary-tree-must-do)
* [Same Tree \$Must Do\$](#5️⃣-same-tree-must-do)
* [Subtree of Another Tree \$Must Do\$](#6️⃣-subtree-of-another-tree-must-do)
* [Lowest Common Ancestor of BST \$Must Do\$](#7️⃣-lowest-common-ancestor-of-bst-must-do)
* [Binary Tree Level Order Traversal \$Must Do\$](#8️⃣-binary-tree-level-order-traversal-must-do)
* [Binary Tree Right Side View \$Must Do\$](#9️⃣-binary-tree-right-side-view-must-do)
* [Count Good Nodes in Binary Tree](#10️⃣-count-good-nodes-in-binary-tree-medium)
* [Validate Binary Search Tree \$Must Do\$](#11️⃣-validate-binary-search-tree-must-do)
* [Kth Smallest Element in BST \$Must Do\$](#12️⃣-kth-smallest-element-in-bst-must-do)
* [Construct Binary Tree from Preorder and Inorder](#13️⃣-construct-binary-tree-from-preorder-and-inorder-medium-hard)
* [Binary Tree Maximum Path Sum](#14️⃣-binary-tree-maximum-path-sum-hard)
* [Serialize and Deserialize Binary Tree](#15️⃣-serialize-and-deserialize-binary-tree-medium-hard)
* [Binary Tree Zigzag Level Order Traversal](#16️⃣-binary-tree-zigzag-level-order-traversal-medium)
* [Serialize and Deserialize BST](#17️⃣-serialize-and-deserialize-bst-medium)




## Section 12: Heap / Priority Queue

* [Kth Largest Element in a Stream \$Must Do\$](#1️⃣-kth-largest-element-in-a-stream-must-do)
* [Last Stone Weight](#2️⃣-last-stone-weight-medium)
* [K Closest Points to Origin \$Must Do\$](#3️⃣-k-closest-points-to-origin-must-do)
* [Kth Largest Element in an Array \$Must Do\$](#4️⃣-kth-largest-element-in-an-array-must-do)
* [Task Scheduler](#5️⃣-task-scheduler-medium-hard)
* [Design Twitter](#6️⃣-design-twitter-hard)
* [Find Median from Data Stream](#7️⃣-find-median-from-data-stream-hard)











## Section 1: Arrays & Hashing

---

### 1️⃣ Contains Duplicate \[Must Do]

**Pattern / Idea:** Use a set to track seen elements. If a number repeats, return True.

**Pseudocode:**

* Initialize empty set `seen`
* For each number `n` in array:

  * If `n` in `seen`, return True
  * Else, add `n` to `seen`
* Return False

**Python Code:**

```python
def containsDuplicate(nums):
    seen = set()
    for n in nums:
        if n in seen:
            return True
        seen.add(n)
    return False
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Set = guard against repeats."

---

### 2️⃣ Valid Anagram

**Pattern / Idea:** Count characters in both strings and compare.

**Pseudocode:**

* If lengths differ → False
* Count characters in both strings
* Compare counts

**Python Code:**

```python
from collections import Counter
def isAnagram(s, t):
    return Counter(s) == Counter(t)
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Same letters, same count."

---

### 3️⃣ Two Sum \[Must Do]

**Pattern / Idea:** Use hash map to store numbers and look for complement.

**Pseudocode:**

* Initialize empty dictionary `d`
* For each index i, num in nums:

  * If target - num in d → return \[d\[target-num], i]
  * Else, store num in d with index

**Python Code:**

```python
def twoSum(nums, target):
    d = {}
    for i, num in enumerate(nums):
        if target - num in d:
            return [d[target - num], i]
        d[num] = i
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Store, check, return."

---

### 4️⃣ Group Anagrams \[Must Do]

**Pattern / Idea:** Strings with same sorted characters belong together. Use hash map.

**Pseudocode:**

* Initialize `groups = defaultdict(list)`
* For each string `s` in strs:

  * Key = sorted(s) → join back to string
  * Append s to `groups[key]`
* Return all groups

**Python Code:**

```python
from collections import defaultdict
def groupAnagrams(strs):
    groups = defaultdict(list)
    for s in strs:
        key = ''.join(sorted(s))
        groups[key].append(s)
    return list(groups.values())
```

**T.C.:** O(n k log k) → n = #strings, k = avg length

**S.C.:** O(n k)

**Quick Recall Hack:** "Sort letters → group."

---

### 5️⃣ Top K Frequent Elements \[Must Do]

**Pattern / Idea:** Count frequency → use heap or bucket sort.

**Pseudocode:**

* Count elements using Counter
* Sort elements by frequency
* Return top K

**Python Code:**

```python
from collections import Counter
def topKFrequent(nums, k):
    count = Counter(nums)
    return [item for item, freq in count.most_common(k)]
```

**T.C.:** O(n log k)

**S.C.:** O(n)

**Quick Recall Hack:** "Count → top K."

---

### 6️⃣ Encode and Decode Strings

**Pattern / Idea:** Encode using delimiter; decode by splitting.

**Pseudocode:**

* Encode: append length + '#' + string
* Decode: parse length, extract substring

**Python Code:**

```python
def encode(strs):
    return ''.join(f'{len(s)}#{s}' for s in strs)

def decode(s):
    res, i = [], 0
    while i < len(s):
        j = i
        while s[j] != '#':
            j += 1
        length = int(s[i:j])
        res.append(s[j+1:j+1+length])
        i = j + 1 + length
    return res
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Length#String → easy parse."

---

### 7️⃣ Product of Array Except Self \[Must Do]

**Pattern / Idea:** Prefix & suffix product arrays.

**Pseudocode:**

* Left product: accumulate from start
* Right product: accumulate from end
* Multiply left\[i] \* right\[i]

**Python Code:**

```python
def productExceptSelf(nums):
    n = len(nums)
    res = [1]*n
    prefix = 1
    for i in range(n):
        res[i] = prefix
        prefix *= nums[i]
    suffix = 1
    for i in range(n-1, -1, -1):
        res[i] *= suffix
        suffix *= nums[i]
    return res
```

**T.C.:** O(n)

**S.C.:** O(1) extra (res counts)

**Quick Recall Hack:** "Prefix \* Suffix = answer."

---

### 8️⃣ Valid Sudoku \[Must Do]

**Pattern / Idea:** Check rows, columns, and 3x3 blocks for duplicates.

**Pseudocode:**

* For each row, col, block:

  * Maintain set
  * If duplicate → False
* Else → True

**Python Code:**

```python
def isValidSudoku(board):
    rows = [set() for _ in range(9)]
    cols = [set() for _ in range(9)]
    boxes = [set() for _ in range(9)]
    for i in range(9):
        for j in range(9):
            num = board[i][j]
            if num == '.':
                continue
            if num in rows[i] or num in cols[j] or num in boxes[(i//3)*3 + j//3]:
                return False
            rows[i].add(num)
            cols[j].add(num)
            boxes[(i//3)*3 + j//3].add(num)
    return True
```

**T.C.:** O(1) → board fixed size

**S.C.:** O(1)

**Quick Recall Hack:** "Row+Col+Box sets."

---

### 9️⃣ Longest Consecutive Sequence \[Must Do]

**Pattern / Idea:** Use a set to expand sequences from sequence starts.

**Pseudocode:**

* Put nums in set
* For each num:

  * If num-1 not in set → start sequence
  * Count consecutive numbers
  * Track max length

**Python Code:**

```python
def longestConsecutive(nums):
    num_set = set(nums)
    max_len = 0
    for n in num_set:
        if n-1 not in num_set:
            length = 1
            while n+length in num_set:
                length += 1
            max_len = max(max_len, length)
    return max_len
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Sequence start → expand."


Perfect. Let’s tackle the **Two Pointers** section in your requested **Problem Format**, marking **must-do non-FAANG problems in brackets**.

---

## Section 2: Two Pointers

---

### 1️⃣ Valid Palindrome \[Must Do]

**Pattern / Idea:** Use two pointers from start and end; skip non-alphanumeric.

**Pseudocode:**

* i = 0, j = len(s)-1
* While i < j:

  * If s\[i] not alnum → i++
  * If s\[j] not alnum → j--
  * If s\[i].lower() != s\[j].lower() → return False
  * Else i++, j--
* Return True

**Python Code:**

```python
def isPalindrome(s):
    i, j = 0, len(s)-1
    while i < j:
        while i < j and not s[i].isalnum():
            i += 1
        while i < j and not s[j].isalnum():
            j -= 1
        if s[i].lower() != s[j].lower():
            return False
        i += 1
        j -= 1
    return True
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Skip junk → match ends."

---

### 2️⃣ Two Sum II – Input Array Is Sorted \[Must Do]

**Pattern / Idea:** Sorted array → two pointers from ends.

**Pseudocode:**

* i = 0, j = len(nums)-1
* While i < j:

  * sum = nums\[i] + nums\[j]
  * If sum == target → return \[i+1, j+1]
  * If sum < target → i++
  * Else → j--

**Python Code:**

```python
def twoSumSorted(nums, target):
    i, j = 0, len(nums)-1
    while i < j:
        s = nums[i] + nums[j]
        if s == target:
            return [i+1, j+1]
        elif s < target:
            i += 1
        else:
            j -= 1
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Sum too small → right up, too big → left down."

---

### 3️⃣ 3Sum \[Must Do]

**Pattern / Idea:** Sort array → fix one element → two pointers for remaining two.

**Pseudocode:**

* Sort nums
* For i in range(n):

  * Skip duplicates
  * left=i+1, right=n-1
  * While left < right:

    * total = nums\[i]+nums\[left]+nums\[right]
    * If total == 0 → add triplet, left++, right-- (skip duplicates)
    * If total < 0 → left++
    * Else → right--

**Python Code:**

```python
def threeSum(nums):
    nums.sort()
    res = []
    for i in range(len(nums)):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        left, right = i+1, len(nums)-1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                res.append([nums[i], nums[left], nums[right]])
                left += 1
                right -= 1
                while left < right and nums[left] == nums[left-1]:
                    left += 1
                while left < right and nums[right] == nums[right+1]:
                    right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    return res
```

**T.C.:** O(n²)

**S.C.:** O(n)

**Quick Recall Hack:** "Sort + fix one + two pointers."

---

### 4️⃣ Container With Most Water \[Must Do]

**Pattern / Idea:** Two pointers → maximize area = min(height) \* width.

**Pseudocode:**

* left=0, right=n-1, max\_area=0
* While left < right:

  * area = min(height\[left], height\[right])\*(right-left)
  * Update max\_area
  * Move smaller height pointer

**Python Code:**

```python
def maxArea(height):
    left, right = 0, len(height)-1
    max_area = 0
    while left < right:
        max_area = max(max_area, min(height[left], height[right])*(right-left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Move smaller → potential increase."

---

### 5️⃣ Trapping Rain Water \[Must Do]

**Pattern / Idea:** Two pointers → track left\_max and right\_max → water = min(left\_max, right\_max)-height.

**Pseudocode:**

* left=0, right=n-1, left\_max=0, right\_max=0, water=0
* While left < right:

  * If height\[left] < height\[right]:

    * left\_max = max(left\_max, height\[left])
    * water += left\_max - height\[left]
    * left++
  * Else:

    * right\_max = max(right\_max, height\[right])
    * water += right\_max - height\[right]
    * right--

**Python Code:**

```python
def trap(height):
    left, right = 0, len(height)-1
    left_max = right_max = water = 0
    while left < right:
        if height[left] < height[right]:
            left_max = max(left_max, height[left])
            water += left_max - height[left]
            left += 1
        else:
            right_max = max(right_max, height[right])
            water += right_max - height[right]
            right -= 1
    return water
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Two sides → trap water."

---



---

## Section 3: Sliding Window

---

### 1️⃣ Best Time to Buy and Sell Stock \[Must Do]

**Pattern / Idea:** Track the minimum price so far. Maximum profit = current price - min price.

* You don’t need nested loops; just one pass.


**Pseudocode:**

* Initialize `min_price = inf`, `max_profit = 0`
* For each price in prices:

  * Update min\_price = min(min\_price, price)
  * Update max\_profit = max(max\_profit, price - min\_price)
* Return max\_profit

**Python Code:**

```python
def maxProfit(prices):
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Track min, update profit."

---

### 2️⃣ Longest Substring Without Repeating Characters \[Must Do]

**Pattern / Idea:** Sliding window → expand window until repeat → shrink from left.

* Use set to check duplicates.


**Pseudocode:**

* left=0, max\_len=0, seen=set()
* For right in range(len(s)):

  * While s\[right] in seen:

    * Remove s\[left] from set
    * left +=1
  * Add s\[right] to set
  * Update max\_len = max(max\_len, right-left+1)

**Python Code:**

```python
def lengthOfLongestSubstring(s):
    seen = set()
    left = 0
    max_len = 0
    for right in range(len(s)):
        while s[right] in seen:
            seen.remove(s[left])
            left += 1
        seen.add(s[right])
        max_len = max(max_len, right-left+1)
    return max_len
```

**T.C.:** O(n)

**S.C.:** O(min(n, charset))

**Quick Recall Hack:** "Expand → shrink when repeat."

---

### 3️⃣ Longest Repeating Character Replacement \[Must Do]

**Pattern / Idea:** Sliding window → keep track of most frequent char in window.

* Max length window = window size - max\_freq ≤ k


**Pseudocode:**

* left=0, count={}
* max\_count=0, max\_len=0
* For right in range(len(s)):

  * count\[s\[right]] +=1
  * max\_count = max(max\_count, count\[s\[right]])
  * If window\_size - max\_count > k → remove s\[left], left++
  * Update max\_len

**Python Code:**

```python
def characterReplacement(s, k):
    count = {}
    left = max_count = max_len = 0
    for right in range(len(s)):
        count[s[right]] = count.get(s[right], 0) + 1
        max_count = max(max_count, count[s[right]])
        while (right - left + 1) - max_count > k:
            count[s[left]] -= 1
            left += 1
        max_len = max(max_len, right - left + 1)
    return max_len
```

**T.C.:** O(n)

**S.C.:** O(26) → English letters

**Quick Recall Hack:** "Window - max freq ≤ k → shrink."

---

### 4️⃣ Permutation in String \[Must Do]

**Pattern / Idea:** Check if a window in s2 is a permutation of s1.

* Fixed window size = len(s1), check counts match.


**Pseudocode:**

* Build freq of s1
* Slide window of size len(s1) over s2
* Keep freq of current window
* If matches → True

**Python Code:**

```python
from collections import Counter
def checkInclusion(s1, s2):
    len1 = len(s1)
    s1_count = Counter(s1)
    window_count = Counter()
    for i in range(len(s2)):
        window_count[s2[i]] += 1
        if i >= len1:
            if window_count[s2[i - len1]] == 1:
                del window_count[s2[i - len1]]
            else:
                window_count[s2[i - len1]] -= 1
        if window_count == s1_count:
            return True
    return False
```

**T.C.:** O(n)

**S.C.:** O(26) → letters

**Quick Recall Hack:** "Slide window, compare counts."

---

### 5️⃣ Minimum Window Substring \[Must Do]

**Pattern / Idea:** Sliding window → include all chars of t, shrink left as much as possible.

* Keep counts of t, compare with window counts.


**Pseudocode:**

* Build count\_t = Counter(t)
* left=0, formed=0, window\_counts={}
* Expand right: add s\[right] to window\_counts
* While window satisfies t:

  * update min\_len, min\_start
  * remove s\[left] from window\_counts, left++
* Return substring

**Python Code:**

```python
from collections import Counter
def minWindow(s, t):
    if not t or not s:
        return ""
    count_t = Counter(t)
    window_counts = {}
    have = 0
    need = len(count_t)
    res = [float("inf"), 0, 0]  # length, start, end
    left = 0
    for right, char in enumerate(s):
        window_counts[char] = window_counts.get(char, 0) + 1
        if char in count_t and window_counts[char] == count_t[char]:
            have += 1
        while have == need:
            if right - left + 1 < res[0]:
                res = [right - left + 1, left, right]
            window_counts[s[left]] -= 1
            if s[left] in count_t and window_counts[s[left]] < count_t[s[left]]:
                have -= 1
            left += 1
    l = res[1]
    r = res[2]
    return s[l:r+1] if res[0] != float("inf") else ""
```

**T.C.:** O(n + m) → n=len(s), m=len(t)

**S.C.:** O(26) → letters

**Quick Recall Hack:** "Expand to satisfy, shrink to minimize."

---

### 6️⃣ Sliding Window Maximum \[Must Do]

**Pattern / Idea:** Use deque to maintain decreasing elements → max at deque\[0].

* Remove smaller elements from back.


**Pseudocode:**

* Initialize deque
* For i in range(len(nums)):

  * Remove indices out of window
  * Remove indices whose nums < nums\[i] from back
  * Append i
  * If i >= k-1 → res.append(nums\[deque\[0]])

**Python Code:**

```python
from collections import deque
def maxSlidingWindow(nums, k):
    dq = deque()
    res = []
    for i, n in enumerate(nums):
        while dq and dq[0] <= i - k:
            dq.popleft()
        while dq and nums[dq[-1]] < n:
            dq.pop()
        dq.append(i)
        if i >= k - 1:
            res.append(nums[dq[0]])
    return res
```

**T.C.:** O(n)

**S.C.:** O(k)

**Quick Recall Hack:** "Deque keeps max at front."

---



Perfect. Let’s tackle the **Stack** section with **ultra-clear cheats to memorize**, step-by-step logic, simple Python code, T.C., S.C., and quick mental hacks. I’ll mark **must-do non-FAANG problems** in brackets.

---

## Section 4: Stack

---

### 1️⃣ Valid Parentheses \[Must Do]

**Pattern / Idea:** Use a stack to track opening brackets; match when closing appears.

**Pseudocode:**

* Initialize empty stack
* For each char:

  * If opening → push
  * If closing → check top of stack matches, else False
* Return True if stack empty

**Python Code:**

```python
def isValid(s):
    stack = []
    mapping = {')':'(', '}':'{', ']':'['}
    for char in s:
        if char in mapping.values():
            stack.append(char)
        else:
            if not stack or stack[-1] != mapping[char]:
                return False
            stack.pop()
    return not stack
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Push opens, pop matches → empty = valid."

**Cheat to memorize:** “Stack = open → push, close → pop.”

---

### 2️⃣ Min Stack \[Must Do]

**Pattern / Idea:** Use auxiliary stack to track min values.

**Pseudocode:**

* main stack: store values
* min stack: store min so far
* Push: push val; push min(val, min\_stack\[-1]) to min\_stack
* Pop: pop both stacks
* Top: return stack\[-1]
* GetMin: return min\_stack\[-1]

**Python Code:**

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val):
        self.stack.append(val)
        if not self.min_stack:
            self.min_stack.append(val)
        else:
            self.min_stack.append(min(val, self.min_stack[-1]))

    def pop(self):
        self.stack.pop()
        self.min_stack.pop()

    def top(self):
        return self.stack[-1]

    def getMin(self):
        return self.min_stack[-1]
```

**T.C.:** O(1) for all operations

**S.C.:** O(n)

**Quick Recall Hack:** "Track min alongside main stack."

**Cheat to memorize:** “Double stack = fast min.”

---

### 3️⃣ Evaluate Reverse Polish Notation \[Must Do]

**Pattern / Idea:** Use stack → push numbers, pop two for operator, push result.

**Pseudocode:**

* Initialize stack
* For each token:

  * If number → push
  * If operator → pop a,b → push b op a
* Return stack\[0]

**Python Code:**

```python
def evalRPN(tokens):
    stack = []
    for t in tokens:
        if t not in "+-*/":
            stack.append(int(t))
        else:
            b = stack.pop()
            a = stack.pop()
            if t == '+': stack.append(a+b)
            elif t == '-': stack.append(a-b)
            elif t == '*': stack.append(a*b)
            else: stack.append(int(a/b))  # truncate toward 0
    return stack[0]
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Numbers push, operator → pop 2 → push result."

**Cheat to memorize:** “Stack = compute on pop.”

---

### 4️⃣ Generate Parentheses \[Must Do]

**Pattern / Idea:** Backtracking → only add '(' if left\<n, only add ')' if right\<left.

**Pseudocode:**

* Recursive function(path, left, right):

  * If len(path)=2n → add path
  * If left\<n → recurse(path+'(', left+1, right)
  * If right\<left → recurse(path+')', left, right+1)

**Python Code:**

```python
def generateParenthesis(n):
    res = []
    def backtrack(path, left, right):
        if len(path) == 2*n:
            res.append(path)
            return
        if left < n:
            backtrack(path+'(', left+1, right)
        if right < left:
            backtrack(path+')', left, right+1)
    backtrack('',0,0)
    return res
```

**T.C.:** O(4^n / √n)

**S.C.:** O(n) recursion

**Quick Recall Hack:** "Left\<n → add (, right\<left → add )"

**Cheat to memorize:** “Only valid opens & closes → recurse.”

---

### 5️⃣ Daily Temperatures \[Must Do]

**Pattern / Idea:** Monotonic decreasing stack → for each temp, pop lower → assign days.

**Pseudocode:**

* Initialize stack = \[]
* For i in range(len(T)):

  * While stack and T\[i] > T\[stack\[-1]]:

    * idx = stack.pop() → res\[idx] = i - idx
  * Push i

**Python Code:**

```python
def dailyTemperatures(T):
    res = [0]*len(T)
    stack = []
    for i, t in enumerate(T):
        while stack and t > T[stack[-1]]:
            idx = stack.pop()
            res[idx] = i - idx
        stack.append(i)
    return res
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Stack stores indices of decreasing temps."

**Cheat to memorize:** “Pop smaller → record days → push current.”

---

### 6️⃣ Car Fleet

**Pattern / Idea:** Sort by position → stack for arrival times → merge fleets.

**Pseudocode:**

* Sort cars by position descending
* For each car: compute time to target
* If time > top of stack → push
* Else → merge

**Python Code:**

```python
def carFleet(target, position, speed):
    cars = sorted(zip(position, speed), reverse=True)
    stack = []
    for p, s in cars:
        t = (target - p)/s
        if not stack or t > stack[-1]:
            stack.append(t)
    return len(stack)
```

**T.C.:** O(n log n)

**S.C.:** O(n)

**Quick Recall Hack:** "Sort → push if slower → else merge."

---

### 7️⃣ Largest Rectangle in Histogram \[Must Do]

**Pattern / Idea:** Monotonic stack → previous smaller → next smaller → width\*height.

**Pseudocode:**

* Append 0 to heights for final flush
* Stack = \[]
* For i in range(len(heights)):

  * While stack and heights\[i] < heights\[stack\[-1]]:

    * h = heights\[stack.pop()]
    * width = i - stack\[-1] - 1 if stack else i
    * update max\_area
  * Append i

**Python Code:**

```python
def largestRectangleArea(heights):
    heights.append(0)
    stack = []
    max_area = 0
    for i, h in enumerate(heights):
        while stack and h < heights[stack[-1]]:
            height = heights[stack.pop()]
            width = i - stack[-1] - 1 if stack else i
            max_area = max(max_area, height*width)
        stack.append(i)
    return max_area
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Stack stores indices → pop smaller → compute area."

**Cheat to memorize:** “Push increasing → pop smaller → area calc.”

---



Perfect. Let’s tackle the **Binary Search** section with **clear step-by-step logic, simple Python code, T.C., S.C., and easy-to-memorize cheats**. I’ll mark **must-do non-FAANG problems** in brackets.

---

## Section 5: Binary Search

---

### 1️⃣ Binary Search \[Must Do]

**Pattern / Idea:** Standard search in sorted array.

**Pseudocode:**

* left = 0, right = n-1
* While left ≤ right:

  * mid = left + (right-left)//2
  * If nums\[mid] == target → return mid
  * If nums\[mid] < target → left = mid+1
  * Else → right = mid-1
* Return -1

**Python Code:**

```python
def binarySearch(nums, target):
    left, right = 0, len(nums)-1
    while left <= right:
        mid = left + (right-left)//2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid+1
        else:
            right = mid-1
    return -1
```

**T.C.:** O(log n)

**S.C.:** O(1)

**Quick Recall Hack:** "Check mid → move left/right."

**Cheat to memorize:** “Divide & conquer → halve each time.”

---

### 2️⃣ Search a 2D Matrix \[Must Do]

**Pattern / Idea:** Treat 2D matrix as 1D sorted array → binary search.

**Pseudocode:**

* rows = len(matrix), cols = len(matrix\[0])
* left = 0, right = rows\*cols-1
* While left ≤ right:

  * mid = (left+right)//2
  * val = matrix\[mid//cols]\[mid%cols]
  * Compare val with target → adjust left/right

**Python Code:**

```python
def searchMatrix(matrix, target):
    if not matrix: return False
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows*cols - 1
    while left <= right:
        mid = (left + right)//2
        val = matrix[mid//cols][mid%cols]
        if val == target:
            return True
        elif val < target:
            left = mid + 1
        else:
            right = mid - 1
    return False
```

**T.C.:** O(log(m*n))

**S.C.:** O(1)

**Quick Recall Hack:** "1D index = row*cols + col."

---

### 3️⃣ Koko Eating Bananas \[Must Do]

**Pattern / Idea:** Binary search on rate → check if possible in given hours.

**Pseudocode:**

* left = 1, right = max(piles)
* While left ≤ right:

  * mid = (left+right)//2 → current rate
  * If canEat(mid) → right = mid-1
  * Else → left = mid+1
* Return left

**Python Code:**

```python
def minEatingSpeed(piles, H):
    def canEat(rate):
        hours = sum((p + rate - 1)//rate for p in piles)
        return hours <= H

    left, right = 1, max(piles)
    while left <= right:
        mid = (left + right)//2
        if canEat(mid):
            right = mid - 1
        else:
            left = mid + 1
    return left
```

**T.C.:** O(n log max(pile))

**S.C.:** O(1)

**Quick Recall Hack:** "Binary search → rate → feasible?"

---

### 4️⃣ Find Minimum in Rotated Sorted Array \[Must Do]

**Pattern / Idea:** Binary search → check mid vs right → decide left/right.

**Pseudocode:**

* left=0, right=n-1
* While left\<right:

  * mid = (left+right)//2
  * If nums\[mid] > nums\[right] → left = mid+1
  * Else → right = mid
* Return nums\[left]

**Python Code:**

```python
def findMin(nums):
    left, right = 0, len(nums)-1
    while left < right:
        mid = (left + right)//2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

**T.C.:** O(log n)

**S.C.:** O(1)

**Quick Recall Hack:** "Compare mid with right → move smaller side."

---

### 5️⃣ Search in Rotated Sorted Array \[Must Do]

**Pattern / Idea:** Binary search → check which half is sorted → adjust left/right.

**Pseudocode:**

* left=0, right=n-1
* While left ≤ right:

  * mid=(left+right)//2
  * If nums\[mid]==target → return mid
  * If nums\[left] ≤ nums\[mid]:

    * If left ≤ target < mid → right=mid-1
    * Else → left=mid+1
  * Else:

    * If mid < target ≤ right → left=mid+1
    * Else → right=mid-1
* Return -1

**Python Code:**

```python
def search(nums, target):
    left, right = 0, len(nums)-1
    while left <= right:
        mid = (left + right)//2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid-1
            else:
                left = mid+1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid+1
            else:
                right = mid-1
    return -1
```

**T.C.:** O(log n)

**S.C.:** O(1)

**Quick Recall Hack:** "Find sorted half → decide side."


---

### 6️⃣ Time-Based Key Value Store \[Must Do]

**Pattern / Idea:** Store times sorted → binary search latest ≤ query.

**Pseudocode:**

* Use dictionary: key → list of (time, value)
* Set: append (time,value)
* Get: binary search last time ≤ query

**Python Code:**

```python
from collections import defaultdict
import bisect

class TimeMap:
    def __init__(self):
        self.store = defaultdict(list)

    def set(self, key, value, timestamp):
        self.store[key].append((timestamp, value))

    def get(self, key, timestamp):
        items = self.store.get(key, [])
        i = bisect.bisect_right(items, (timestamp, chr(127)))
        return items[i-1][1] if i else ""
```

**T.C.:** O(log n) for get

**S.C.:** O(n)

**Quick Recall Hack:** "Binary search in timestamp list."

---



Perfect. Here's the **updated Greedy section** with your version of **Maximum Subarray** included, keeping everything clear, concise, and with cheat codes for memorization.

---

## Section 6: Greedy

---

### 1️⃣ Maximum Subarray \[Must Do]

**Pattern / Idea:** Kadane’s Algorithm → if running sum < 0, reset to 0; otherwise, add current number. Track maximum sum seen so far.

**Pseudocode:**

* res = nums\[0], total = nums\[0]
* For each num in nums\[1:]:

  * If total < 0 → reset total = 0
  * total += num
  * res = max(res, total)
* Return res

**Python Code:**

```python
from typing import List

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = nums[0]
        total = nums[0]
        for num in nums[1:]:
            if total < 0:
                total = 0
            total += num
            res = max(res, total)
        return res
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Reset if sum <0, else add → track max."

**Cheat to memorize:** “Kadane = reset bad sum, keep running max.”

### OR


**Maximum subarray sum = max(current_sum, max_sum).**

**Pseudocode:**

max_sum = current_sum = nums[0]

For i in 1 to n-1:

current_sum = max(nums[i], current_sum + nums[i])

max_sum = max(max_sum, current_sum)

Return max_sum

Python Code:
```python
def maxSubArray(nums):
    max_sum = current_sum = nums[0]
    for n in nums[1:]:
        current_sum = max(n, current_sum + n)
        max_sum = max(max_sum, current_sum)
    return max_sum
```

T.C.: O(n)

S.C.: O(1)

Quick Recall Hack: "Add if helps, reset if hurts."

---

### 2️⃣ Jump Game \[Must Do]

**Pattern / Idea:** Track farthest reachable index → if i > farthest → False.

**Pseudocode:**

* max\_reach = 0
* For i in range(len(nums)):

  * If i > max\_reach → return False
  * max\_reach = max(max\_reach, i + nums\[i])
* Return True

**Python Code:**

```python
def canJump(nums):
    max_reach = 0
    for i, n in enumerate(nums):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i+n)
    return True
```

**T.C.:** O(n)
**S.C.:** O(1)
**Quick Recall Hack:** "Keep farthest reach → fail if you fall behind."

---

### 3️⃣ Jump Game II \[Must Do]

**Pattern / Idea:** Greedy → jump to farthest within current jump.

* Count jumps each time you exhaust current range.

**Pseudocode:**

* jumps = 0, current\_end = 0, farthest = 0
* For i in 0 to n-2:

  * farthest = max(farthest, i + nums\[i])
  * If i == current\_end:

    * jumps +=1
    * current\_end = farthest
* Return jumps

**Python Code:**

```python
def jump(nums):
    jumps = current_end = farthest = 0
    for i in range(len(nums)-1):
        farthest = max(farthest, i + nums[i])
        if i == current_end:
            jumps += 1
            current_end = farthest
    return jumps
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Jump only when range ends."

---

### 4️⃣ Gas Station \[Must Do]

**Pattern / Idea:** Greedy → if total gas ≥ total cost → solution exists. Track start index.

**Pseudocode:**

* total = curr = start = 0
* For i in range(n):

  * curr += gas\[i] - cost\[i]
  * total += gas\[i] - cost\[i]
  * If curr <0 → start = i+1, curr=0
* Return start if total ≥0 else -1

**Python Code:**

```python
def canCompleteCircuit(gas, cost):
    total = curr = start = 0
    for i in range(len(gas)):
        curr += gas[i] - cost[i]
        total += gas[i] - cost[i]
        if curr < 0:
            start = i+1
            curr = 0
    return start if total >= 0 else -1
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Reset start if tank goes negative."

---

### 5️⃣ Hand of Straights

**Pattern / Idea:** Use Counter + sort → always pick smallest first.

**Pseudocode:**

* Count frequencies → keys sorted
* For key in sorted keys:

  * while freq\[key] > 0:

    * For i in key to key+groupSize-1:

      * If freq\[i] < freq\[key] → return False
      * freq\[i] -= freq\[key]

**Python Code:**

```python
from collections import Counter
def isNStraightHand(hand, W):
    count = Counter(hand)
    for x in sorted(count):
        if count[x] > 0:
            for i in range(x, x+W):
                if count[i] < count[x]:
                    return False
                count[i] -= count[x]
    return True
```

**T.C.:** O(n log n)

**S.C.:** O(n)

**Quick Recall Hack:** "Always start from smallest → remove sequence."

---

### 6️⃣ Merge Triplets to Form Target Triplet

**Pattern / Idea:** Keep track of max values for each position ≤ target.

* Greedy → update achievable max.

**Python Code:**

```python
def mergeTriplets(triplets, target):
    a = b = c = 0
    for x, y, z in triplets:
        if x <= target[0] and y <= target[1] and z <= target[2]:
            a, b, c = max(a, x), max(b, y), max(c, z)
    return [a, b, c] == target
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Update max ≤ target → check final match."

---

### 7️⃣ Partition Labels

**Pattern / Idea:** Greedy → keep track of last occurrence → split partitions.

**Python Code:**

```python
def partitionLabels(s):
    last = {c:i for i,c in enumerate(s)}
    j = anchor = 0
    res = []
    for i, c in enumerate(s):
        j = max(j, last[c])
        if i == j:
            res.append(i - anchor + 1)
            anchor = i+1
    return res
```

**T.C.:** O(n)
**S.C.:** O(1)
**Quick Recall Hack:** "Partition when farthest index reached."

---

### 8️⃣ Valid Parenthesis String

**Pattern / Idea:** Greedy → track minOpen and maxOpen → for ‘\*’ treat as '(' or ')'.

**Python Code:**

```python
def checkValidString(s):
    minOpen = maxOpen = 0
    for c in s:
        if c == '(':
            minOpen += 1
            maxOpen += 1
        elif c == ')':
            minOpen = max(minOpen-1, 0)
            maxOpen -= 1
        else:  # '*'
            minOpen = max(minOpen-1, 0)
            maxOpen += 1
        if maxOpen < 0:
            return False
    return minOpen == 0
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Track min & max opens."

---



Got it. Let’s **crack Intervals problems** in a super-clear way, step by step, without confusing stuff like obscure lambdas. I’ll also explain why we do each step, so you actually **understand**, not just memorize.

We’ll start with the **core patterns**, then go problem by problem. I’ll mark **must-do non-FAANG problems**.

---

# Section 7: Intervals

---

### **Pattern / Idea for Intervals:**

1. **Sorting is almost always key** → either by start time or end time.
2. **Greedy merges or checks** → because intervals are continuous, you can make decisions locally.
3. **Lambda** is just a short way to sort with a key. Instead of worrying about it, think:

   * `sorted(intervals, key=lambda x: x[0])` → sort by start time
   * You can replace with a normal function or manual comparison if lambda confuses you.

**Cheat to memorize:** "Sort first → merge/compare → decide greedily."

---

### 1️⃣ Insert Interval \[Must Do]

**Problem:** Given a list of non-overlapping intervals sorted by start time, insert a new interval and merge if necessary.

**Pattern / Idea:**

* Append intervals that **end before** new interval → no overlap.
* Merge intervals that **overlap** with new interval.
* Append intervals that **start after** new interval → no overlap.

**Python Code (Simple, No Lambda Confusion):**

```python
def insert(intervals, newInterval):
    res = []
    i = 0
    n = len(intervals)
    
    # Add intervals before newInterval
    while i < n and intervals[i][1] < newInterval[0]:
        res.append(intervals[i])
        i += 1

    # Merge overlapping intervals
    while i < n and intervals[i][0] <= newInterval[1]:
        newInterval[0] = min(newInterval[0], intervals[i][0])
        newInterval[1] = max(newInterval[1], intervals[i][1])
        i += 1
    res.append(newInterval)

    # Add remaining intervals
    while i < n:
        res.append(intervals[i])
        i += 1

    return res
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Before → add, Overlap → merge, After → add."

---

### 2️⃣ Merge Intervals \[Must Do]

**Problem:** Merge all overlapping intervals.

**Pattern / Idea:**

1. Sort intervals by start time.
2. Keep a `merged` list.
3. For each interval:

   * If it **overlaps** with last merged → merge
   * Else → append

**Python Code (Simple, No Lambda Confusion):**

```python
def merge(intervals):
    if not intervals:
        return []
    
    intervals.sort(key=lambda x: x[0])  # Sort by start
    merged = [intervals[0]]
    
    for curr in intervals[1:]:
        last = merged[-1]
        if curr[0] <= last[1]:  # Overlap
            last[1] = max(last[1], curr[1])
        else:
            merged.append(curr)
    
    return merged
```

**T.C.:** O(n log n) (for sorting)

**S.C.:** O(n)

**Quick Recall Hack:** "Sort → compare with last → merge if overlap."

**Tip:** If lambda confuses you, think `sort(intervals, key=getStart)` where `getStart(interval)` returns interval\[0]. Same idea.

---

### 3️⃣ Non-Overlapping Intervals \[Must Do]

**Problem:** Given intervals, find minimum number of intervals to remove so that no overlaps remain.

**Pattern / Idea:**

* Sort by **end time** (important!)
* Keep track of `prev_end`.
* If current start < prev\_end → remove one.

**Python Code:**

```python
def eraseOverlapIntervals(intervals):
    if not intervals:
        return 0
    
    intervals.sort(key=lambda x: x[1])  # Sort by end time
    prev_end = intervals[0][1]
    remove = 0
    
    for i in range(1, len(intervals)):
        if intervals[i][0] < prev_end:
            remove += 1  # Overlap → remove current
        else:
            prev_end = intervals[i][1]
    
    return remove
```

**T.C.:** O(n log n)

**S.C.:** O(1)

**Quick Recall Hack:** "Sort by end → remove overlaps greedily."

---

### 4️⃣ Meeting Rooms

**Problem:** Given intervals, check if a person can attend all meetings.

**Pattern / Idea:**

* Sort by start.
* If any interval’s start < previous end → cannot attend all.

**Python Code:**

```python
def canAttendMeetings(intervals):
    intervals.sort(key=lambda x: x[0])
    for i in range(1, len(intervals)):
        if intervals[i][0] < intervals[i-1][1]:
            return False
    return True
```

**T.C.:** O(n log n)

**S.C.:** O(1)

**Quick Recall Hack:** "Sort by start → check consecutive overlap."

---

### 5️⃣ Meeting Rooms II \[Must Do]

**Problem:** Minimum number of meeting rooms needed.

**Pattern / Idea:**

* Use **two arrays**: start times and end times.
* Use two pointers → track how many meetings overlap → max is answer.

**Python Code (Simple, No Heap Needed):**

```python
def minMeetingRooms(intervals):
    if not intervals:
        return 0
    
    starts = sorted([i[0] for i in intervals])
    ends = sorted([i[1] for i in intervals])
    
    s = e = 0
    rooms = 0
    max_rooms = 0
    
    while s < len(intervals):
        if starts[s] < ends[e]:
            rooms += 1
            s += 1
        else:
            rooms -= 1
            e += 1
        max_rooms = max(max_rooms, rooms)
    
    return max_rooms
```

**T.C.:** O(n log n)

**S.C.:** O(n)

**Quick Recall Hack:** "Sort starts & ends → sweep → track overlap."

---

### 6️⃣ Minimum Interval to Include Each Query

**Pattern / Idea:**

* Sort intervals by start.
* For each query, check which intervals cover it → track minimum size.
* Use heap for efficiency if many queries.

*(This one is harder → usually you use heap. We can do a simple version later if you want.)*

---







# Section 8: Math & Geometry

---

### 1️⃣ Rotate Image \[Must Do]

**Problem:** Rotate an n × n matrix 90° clockwise **in-place**.

**Pattern / Idea:**

* Transpose the matrix → swap `matrix[i][j]` with `matrix[j][i]`
* Reverse each row

**Python Code:**

```python
def rotate(matrix):
    n = len(matrix)
    # Transpose
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # Reverse each row
    for row in matrix:
        row.reverse()
```

**T.C.:** O(n²)

**S.C.:** O(1)

**Quick Recall Hack:** "Transpose → reverse rows."

---

### 2️⃣ Spiral Matrix \[Must Do]

**Problem:** Return elements of a matrix in spiral order.

**Pattern / Idea:**

* Keep four boundaries: top, bottom, left, right
* Move right → down → left → up
* Shrink boundaries after each pass

**Python Code:**

```python
def spiralOrder(matrix):
    res = []
    if not matrix: return res
    top, bottom, left, right = 0, len(matrix)-1, 0, len(matrix[0])-1
    while top <= bottom and left <= right:
        for j in range(left, right+1):
            res.append(matrix[top][j])
        top += 1
        for i in range(top, bottom+1):
            res.append(matrix[i][right])
        right -= 1
        if top <= bottom:
            for j in range(right, left-1, -1):
                res.append(matrix[bottom][j])
            bottom -= 1
        if left <= right:
            for i in range(bottom, top-1, -1):
                res.append(matrix[i][left])
            left += 1
    return res
```

**T.C.:** O(m\*n)

**S.C.:** O(1) extra

**Quick Recall Hack:** "Keep shrinking boundaries → traverse in four directions."

---

### 3️⃣ Set Matrix Zeroes \[Must Do]

**Problem:** If an element is 0, set its entire row and column to 0 **in-place**.

**Pattern / Idea:**

* Use first row & first column as markers
* Track separately if first row/column has zero

**Python Code:**

```python
def setZeroes(matrix):
    rows, cols = len(matrix), len(matrix[0])
    first_row = any(matrix[0][j] == 0 for j in range(cols))
    first_col = any(matrix[i][0] == 0 for i in range(rows))
    
    # Mark zeros
    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][j] == 0:
                matrix[i][0] = matrix[0][j] = 0
    
    # Apply markers
    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0
    
    # First row/col
    if first_row:
        for j in range(cols):
            matrix[0][j] = 0
    if first_col:
        for i in range(rows):
            matrix[i][0] = 0
```

**T.C.:** O(m\*n)

**S.C.:** O(1) extra

**Quick Recall Hack:** "Use first row & col as flags."

---

### 4️⃣ Happy Number \[Must Do]

**Problem:** Determine if number eventually reaches 1 by replacing it with sum of squares of digits repeatedly.

**Pattern / Idea:**

* Detect cycle using **Floyd’s Tortoise and Hare**

**Python Code:**

```python
def isHappy(n):
    def get_next(x):
        return sum(int(d)**2 for d in str(x))
    
    slow = n
    fast = get_next(n)
    while fast != 1 and slow != fast:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    return fast == 1
```

**T.C.:** O(log n) (since numbers shrink)

**S.C.:** O(1)

**Quick Recall Hack:** "Detect cycle → sum of squares."

---

### 5️⃣ Plus One \[Must Do]

**Problem:** Increment an integer represented as an array of digits.

**Pattern / Idea:**

* Add 1 from last digit → handle carry

**Python Code:**

```python
def plusOne(digits):
    n = len(digits)
    for i in range(n-1, -1, -1):
        if digits[i] < 9:
            digits[i] += 1
            return digits
        digits[i] = 0
    return [1] + digits
```

**T.C.:** O(n)

**S.C.:** O(1) (or O(n) if new array)

**Quick Recall Hack:** "Add from end → propagate carry."

---

### 6️⃣ Pow(x, n) \[Must Do]

**Problem:** Compute xⁿ efficiently.

**Pattern / Idea:**

* Use **binary exponentiation**
* n even → square result, n odd → multiply

**Python Code:**

```python
def myPow(x, n):
    if n < 0:
        x = 1/x
        n = -n
    res = 1
    while n:
        if n % 2:
            res *= x
        x *= x
        n //= 2
    return res
```

**T.C.:** O(log n)

**S.C.:** O(1)

**Quick Recall Hack:** "Square & multiply → halve exponent."

---

### 7️⃣ Multiply Strings \[Must Do]

**Problem:** Multiply two numbers given as strings.

**Pattern / Idea:**

* Simulate multiplication like on paper → store in array

**Python Code:**

```python
def multiply(num1, num2):
    m, n = len(num1), len(num2)
    res = [0]*(m+n)
    
    for i in range(m-1, -1, -1):
        for j in range(n-1, -1, -1):
            mul = int(num1[i])*int(num2[j])
            sum_ = mul + res[i+j+1]
            res[i+j+1] = sum_ % 10
            res[i+j] += sum_ // 10
    
    # Convert to string, remove leading zeros
    result = ''.join(map(str, res)).lstrip('0')
    return result or '0'
```

**T.C.:** O(m\*n)

**S.C.:** O(m+n)

**Quick Recall Hack:** "Simulate school multiplication → store digits."

---

### 8️⃣ Detect Squares

**Problem:** Count number of squares formed from points (advanced geometry).

**Pattern / Idea:**

* Use combinations → check distances
* Only important if high-level; can skip memorizing tricks for interview unless needed


---

### 9️⃣ Detect Triangles \[Must Do]

**Problem:** Given an array of integers, count the number of triplets (i, j, k) such that `nums[i] + nums[j] > nums[k]` (triangle inequality).

**Pattern / Idea:**

* Sort array → because triangle inequality only needs `a + b > c` for sides in order.
* Use **two pointers** to efficiently count valid triplets.

**Pseudocode:**

1. Sort `nums`
2. For `k` from n-1 down to 2 (largest side):

   * left = 0, right = k-1
   * While left < right:

     * If nums\[left] + nums\[right] > nums\[k]:

       * count += right - left
       * right -= 1
     * Else:

       * left += 1

**Python Code:**

```python
def triangleNumber(nums):
    nums.sort()
    count = 0
    n = len(nums)
    for k in range(n-1, 1, -1):
        left, right = 0, k-1
        while left < right:
            if nums[left] + nums[right] > nums[k]:
                count += right - left
                right -= 1
            else:
                left += 1
    return count
```

**T.C.:** O(n²)

**S.C.:** O(1)

**Quick Recall Hack:** "Sort → fix largest → two pointers for left + right."

**Cheat to memorize:** "Largest side last → smaller two → count all valid."



# Section 9: Bit manipulation  **Bit Manipulation – Core Tricks**

---

### **1️⃣ Get the rightmost set bit**

**Trick:** `x & -x`

**What it does:**

* Gives a number with **only the rightmost 1 bit** of `x` set.

**Example:**

```text
x = 12 -> 1100 in binary
-x = -12 -> two’s complement = 0100 (last 1)
x & -x = 1100 & 0100 = 0100 = 4
```

**Use case:**

* Often used in **Single Number II** or **finding subsets**.

**Cheat to memorize:** “x & -x isolates last 1.”

---

### **2️⃣ Turn off the rightmost set bit**

**Trick:** `x & (x - 1)`

**What it does:**

* Removes the **lowest 1 bit** in x.

**Example:**

```text
x = 12 -> 1100
x - 1 = 11 -> 1011
x & (x-1) = 1100 & 1011 = 1000 = 8
```

**Use case:**

* Count number of 1’s in a number
* Detect powers of two (`x & (x-1) == 0`)

**Cheat to memorize:** “x & (x-1) kills last 1.”

---

### **3️⃣ Check if a number is power of 2**

**Trick:** `x > 0 and (x & (x - 1)) == 0`

**Why it works:**

* Powers of two have **exactly one 1-bit**.

**Example:**

```text
x = 8 -> 1000
x & (x-1) = 1000 & 0111 = 0 -> yes
x = 6 -> 0110
x & (x-1) = 0110 & 0101 = 0100 -> not 0
```

**Cheat:** “Power of two → only one 1-bit → x & (x-1) = 0.”

---

### **4️⃣ Count number of 1 bits (Brian Kernighan’s Algorithm)**

**Trick:** repeatedly use `x = x & (x-1)` until x becomes 0

**Example:**

```python
def countBits(x):
    count = 0
    while x:
        x &= x-1  # remove last set bit
        count += 1
    return count
```

**Example Run:**

* x = 12 → 1100
* 1st: 1100 & 1011 = 1000 → count=1
* 2nd: 1000 & 0111 = 0 → count=2

**Cheat:** “Each & (x-1) removes a 1 → count steps = number of 1’s.”

---

### **5️⃣ XOR tricks**

**Properties:**

1. `x ^ x = 0`
2. `x ^ 0 = x`
3. XOR is **commutative and associative**

**Use case:**

* Single Number problems
* Swapping numbers without temp variable

**Example – Single Number:**

```python
nums = [2,3,2]
res = 0
for num in nums:
    res ^= num
# res = 3
```

**Cheat:** “XOR cancels duplicates.”

---

### **6️⃣ Check if two numbers have opposite signs**

**Trick:** `(x ^ y) < 0`

**Why it works:**

* XOR of numbers with opposite signs → most significant bit = 1 → negative

**Example:**

```text
x = 5 (0101), y = -3 (two's complement 1101)
x ^ y = 1000 < 0 → True
```

---

### **7️⃣ Swap two numbers using XOR**

**Trick:**

```python
x = x ^ y
y = x ^ y
x = x ^ y
```

**Why it works:**

* Each step XORs out the original value.
* Avoids temporary variable.

---

### **8️⃣ Isolate last 0 bit**

**Trick:** `~x & (x + 1)`

**Example:**

```text
x = 10 -> 1010
x + 1 = 1011
~x = 0101
~x & (x+1) = 0101 & 1011 = 0001
```

**Use case:**

* Rare, mainly in advanced bitmask problems.

---

### **9️⃣ Count bits from 0…n (dynamic programming)**

**Trick:** `bits[i] = bits[i & (i-1)] + 1`

**Idea:**

* Use previously computed counts
* Efficient for “Counting Bits” problem

---

### **10️⃣ Subsets using bitmask**

**Pattern:**

* Treat 1s in binary as elements included
* Loop `i` from `0` to `2^n - 1`

**Example:**

```python
nums = [1,2,3]
for mask in range(1<<len(nums)):
    subset = [nums[j] for j in range(len(nums)) if mask & (1<<j)]
    print(subset)
```

**Cheat:** “Binary mask → subset yes/no for each bit.”



Perfect. Let’s convert your **Bit Manipulation** problems into the same **interview-ready format** with patterns, clear Python code, T.C./S.C., and quick cheat hacks. I’ll mark the **must-do ones** for non-FAANG interviews.

---

# **Bit Problems**

---

### 1️⃣ Single Number \[Must Do]

**Pattern / Idea:**

* Use **XOR** to cancel duplicates → `x ^ x = 0`

**Pseudocode:**

* res = 0
* For each num in nums → res ^= num
* Return res

**Python Code:**

```python
def singleNumber(nums):
    res = 0
    for num in nums:
        res ^= num
    return res
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “XOR cancels duplicates → left with single.”

---

### 2️⃣ Number of 1 Bits \[Must Do]

**Pattern / Idea:**

* Use **Brian Kernighan’s Algorithm** → repeatedly remove last set bit

**Python Code:**

```python
def hammingWeight(n):
    count = 0
    while n:
        n &= n-1
        count += 1
    return count
```

**T.C.:** O(number of 1s)

**S.C.:** O(1)

**Quick Recall Hack:** “Each & (n-1) kills last 1 → count = # of 1s.”

---

### 3️⃣ Counting Bits \[Must Do]

**Pattern / Idea:**

* Dynamic programming using **last set bit removal**:
  `bits[i] = bits[i & (i-1)] + 1`

**Python Code:**

```python
def countBits(n):
    bits = [0]*(n+1)
    for i in range(1, n+1):
        bits[i] = bits[i & (i-1)] + 1
    return bits
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** “Use previous smaller number by removing last 1.”

---

### 4️⃣ Reverse Bits \[Must Do]

**Pattern / Idea:**

* Shift bits → build reversed number

**Python Code:**

```python
def reverseBits(n):
    res = 0
    for _ in range(32):
        res = (res << 1) | (n & 1)
        n >>= 1
    return res
```

**T.C.:** O(32) → O(1)

**S.C.:** O(1)

**Quick Recall Hack:** “Shift left result + last bit from n.”

---

### 5️⃣ Missing Number \[Must Do]

**Pattern / Idea:**

* XOR all indices and all numbers → missing one remains

**Python Code:**

```python
def missingNumber(nums):
    n = len(nums)
    res = n
    for i, num in enumerate(nums):
        res ^= i ^ num
    return res
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “XOR indices & values → missing number left.”

---

### 6️⃣ Sum of Two Integers \[Must Do]

**Pattern / Idea:**

* Use **bitwise operations** to sum without `+`

**Python Code:**

```python
def getSum(a, b):
    mask = 0xFFFFFFFF
    while b != 0:
        a, b = (a ^ b) & mask, ((a & b) << 1) & mask
    # Handle negative numbers
    return a if a <= 0x7FFFFFFF else ~(a ^ mask)
```

**T.C.:** O(32) → O(1)

**S.C.:** O(1)

**Quick Recall Hack:** “XOR = sum, AND+shift = carry → repeat.”

---

### 7️⃣ Reverse Integer \[Must Do]

**Pattern / Idea:**

* Pop last digit → push to result
* Check overflow

**Python Code:**

```python
def reverse(x):
    res = 0
    sign = -1 if x < 0 else 1
    x = abs(x)
    while x:
        res = res*10 + x%10
        x //= 10
    res *= sign
    if res < -2**31 or res > 2**31-1:
        return 0
    return res
```

**T.C.:** O(log n)

**S.C.:** O(1)

**Quick Recall Hack:** “Pop & push digits → check 32-bit overflow.”


### ✅ Summary Cheats for Bit Manipulation:

1. **XOR cancels duplicates** → `x ^ x = 0`
2. **Remove last set bit** → `x & (x-1)`
3. **Isolate last 1 bit** → `x & -x`
4. **Check power of 2** → `(x & (x-1)) == 0`
5. **Count 1 bits** → repeatedly `x &= x-1`
6. **Subsets** → bitmask → `(mask & (1<<i))`
7. **Sum without +** → `a ^ b` (sum), `(a & b) << 1` (carry)

---




---

# **Section 10: Linked List**

---

### 1️⃣ Reverse Linked List \[Must Do]

**Pattern / Idea:**

* Iteratively reverse pointers → previous, current, next

**Python Code:**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None
    curr = head
    while curr:
        nxt = curr.next
        curr.next = prev
        prev = curr
        curr = nxt
    return prev
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “Prev → Curr → Next → reverse pointer.”

---

### 2️⃣ Merge Two Sorted Lists \[Must Do]

**Pattern / Idea:**

* Use dummy node → iterate both lists → pick smaller each step

**Python Code:**

```python
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    tail = dummy
    while l1 and l2:
        if l1.val < l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next
    tail.next = l1 or l2
    return dummy.next
```

**T.C.:** O(n + m)

**S.C.:** O(1)

**Quick Recall Hack:** “Dummy + tail → pick smaller → move pointers.”

---

### 3️⃣ Linked List Cycle \[Must Do]

**Pattern / Idea:**

* Use **Floyd’s Tortoise and Hare** → slow & fast pointers

**Python Code:**

```python
def hasCycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “Slow + Fast → meet = cycle.”

---

### 4️⃣ Reorder List \[Must Do]

**Problem:** L0 → L1 → … → Ln → reorder to L0 → Ln → L1 → Ln-1 …

**Pattern / Idea:**

* Find middle → reverse second half → merge two halves

**Python Code:**

```python
def reorderList(head):
    if not head or not head.next:
        return
    # Find middle
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    # Reverse second half
    prev, curr = None, slow.next
    slow.next = None
    while curr:
        nxt = curr.next
        curr.next = prev
        prev = curr
        curr = nxt
    # Merge halves
    first, second = head, prev
    while second:
        tmp1, tmp2 = first.next, second.next
        first.next, second.next = second, tmp1
        first, second = tmp1, tmp2
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “Middle → reverse → merge.”

---

### 5️⃣ Remove Nth Node From End \[Must Do]

**Pattern / Idea:**

* Two pointers → first advances n steps → move both until first is end → remove node

**Python Code:**

```python
def removeNthFromEnd(head, n):
    dummy = ListNode(0)
    dummy.next = head
    first = second = dummy
    for _ in range(n+1):
        first = first.next
    while first:
        first = first.next
        second = second.next
    second.next = second.next.next
    return dummy.next
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “Two pointers → remove nth from end.”

---

### 6️⃣ Copy List With Random Pointer \[Must Do]

**Pattern / Idea:**

* Use interleaving nodes → copy random pointers → separate lists

**Python Code:**

```python
class Node:
    def __init__(self, val, next=None, random=None):
        self.val = val
        self.next = next
        self.random = random

def copyRandomList(head):
    if not head:
        return None
    # Step 1: copy nodes interleaved
    curr = head
    while curr:
        nxt = curr.next
        curr.next = Node(curr.val)
        curr.next.next = nxt
        curr = nxt
    # Step 2: copy random
    curr = head
    while curr:
        if curr.random:
            curr.next.random = curr.random.next
        curr = curr.next.next
    # Step 3: separate lists
    curr, copy = head, head.next
    head_copy = copy
    while curr:
        curr.next = curr.next.next
        copy.next = copy.next.next if copy.next else None
        curr = curr.next
        copy = copy.next
    return head_copy
```

**T.C.:** O(n)

**S.C.:** O(1) extra (interleaving trick)

**Quick Recall Hack:** “Interleave → copy random → separate.”

---

### 7️⃣ Add Two Numbers \[Must Do]

**Pattern / Idea:**

* Iteratively add corresponding digits → carry → new node

**Python Code:**

```python
def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr, carry = dummy, 0
    while l1 or l2 or carry:
        val = carry
        if l1:
            val += l1.val
            l1 = l1.next
        if l2:
            val += l2.val
            l2 = l2.next
        carry, val = divmod(val, 10)
        curr.next = ListNode(val)
        curr = curr.next
    return dummy.next
```

**T.C.:** O(max(n, m))

**S.C.:** O(max(n, m))

**Quick Recall Hack:** “Digit-wise addition → carry → append.”

---

### 8️⃣ Find the Duplicate Number \[Must Do]

**Pattern / Idea:**

* **Linked List cycle detection trick** using indices → Floyd’s Tortoise & Hare

**Python Code:**

```python
def findDuplicate(nums):
    slow = fast = nums[0]
    while True:
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast:
            break
    slow = nums[0]
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]
    return slow
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “Array values as pointers → detect cycle.”

---

### 9️⃣ LRU Cache \[Must Do]

**Pattern / Idea:**

* Use **OrderedDict or doubly linked list + hashmap** → O(1) get & put

**Python Code:**

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key):
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key, value):
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**T.C.:** O(1)

**S.C.:** O(capacity)

**Quick Recall Hack:** “OrderedDict → move\_to\_end → pop oldest.”

---

### 10️⃣ Merge K Sorted Lists \[Must Do]

**Pattern / Idea:**

* Use **heap (priority queue)** → always take smallest head

**Python Code:**

```python
from heapq import heappush, heappop

def mergeKLists(lists):
    heap = []
    for i, node in enumerate(lists):
        if node:
            heappush(heap, (node.val, i, node))
    dummy = curr = ListNode(0)
    while heap:
        val, i, node = heappop(heap)
        curr.next = node
        curr = curr.next
        if node.next:
            heappush(heap, (node.next.val, i, node.next))
    return dummy.next
```

**T.C.:** O(N log k) (N = total nodes, k = lists)

**S.C.:** O(k)

**Quick Recall Hack:** “Heap → always smallest head → append → push next.”

---

### 11️⃣ Reverse Nodes in k-Group \[Must Do]

**Pattern / Idea:**

* Reverse every k nodes → use dummy → iterative solution

**Python Code:**

```python
def reverseKGroup(head, k):
    dummy = jump = ListNode(0)
    dummy.next = head
    prev = head
    count = 0
    while head:
        count += 1
        if count % k == 0:
            prev = reverse(prev, jump.next, head.next)
            jump = prev
            head = prev.next
        else:
            head = head.next
    return dummy.next

def reverse(start, first, last):
    prev = last
    curr = first
    while curr != last:
        nxt = curr.next
        curr.next = prev
        prev = curr
        curr = nxt
    start.next = prev
    return first
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “Reverse every k nodes → connect properly.”






---

# ** Section 11: Trees**

---

### 1️⃣ Invert Binary Tree \[Must Do]

**Pattern / Idea:**

* **Recursive swap** left and right children of every node

**Python Code:**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def invertTree(root):
    if not root:
        return None
    root.left, root.right = invertTree(root.right), invertTree(root.left)
    return root
```

**T.C.:** O(n)

**S.C.:** O(h) recursion stack, h = height

**Quick Recall Hack:** “Swap left & right recursively.”

---

### 2️⃣ Maximum Depth of Binary Tree \[Must Do]

**Pattern / Idea:**

* DFS recursion → max(left, right) + 1

**Python Code:**

```python
def maxDepth(root):
    if not root:
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “Depth = 1 + max of children.”

---

### 3️⃣ Diameter of Binary Tree \[Must Do]

**Pattern / Idea:**

* Diameter = max(left\_depth + right\_depth) at any node

**Python Code:**

```python
def diameterOfBinaryTree(root):
    res = 0
    def dfs(node):
        nonlocal res
        if not node:
            return 0
        left, right = dfs(node.left), dfs(node.right)
        res = max(res, left + right)
        return 1 + max(left, right)
    dfs(root)
    return res
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “Diameter = left\_depth + right\_depth max.”

---

### 4️⃣ Balanced Binary Tree \[Must Do]

**Pattern / Idea:**

* Check recursively → left/right height difference ≤ 1

**Python Code:**

```python
def isBalanced(root):
    def dfs(node):
        if not node:
            return 0, True
        lh, lb = dfs(node.left)
        rh, rb = dfs(node.right)
        height = 1 + max(lh, rh)
        balanced = lb and rb and abs(lh - rh) <= 1
        return height, balanced
    return dfs(root)[1]
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “Check height difference ≤ 1 recursively.”

---

### 5️⃣ Same Tree \[Must Do]

**Pattern / Idea:**

* DFS → compare values + recursively left and right

**Python Code:**

```python
def isSameTree(p, q):
    if not p and not q:
        return True
    if not p or not q or p.val != q.val:
        return False
    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “Values + structure must match recursively.”

---

### 6️⃣ Subtree of Another Tree \[Must Do]

**Pattern / Idea:**

* For each node in s → check if tree equals t

**Python Code:**

```python
def isSubtree(s, t):
    def isSame(a, b):
        if not a and not b:
            return True
        if not a or not b or a.val != b.val:
            return False
        return isSame(a.left, b.left) and isSame(a.right, b.right)
    
    if not s:
        return False
    return isSame(s, t) or isSubtree(s.left, t) or isSubtree(s.right, t)
```

**T.C.:** O(m\*n) worst-case

**S.C.:** O(h)

**Quick Recall Hack:** “Check every node for equality.”

---

### 7️⃣ Lowest Common Ancestor of BST \[Must Do]

**Pattern / Idea:**

* BST property → if root > both → go left, if root < both → go right, else root is LCA

**Python Code:**

```python
def lowestCommonAncestor(root, p, q):
    if root.val > p.val and root.val > q.val:
        return lowestCommonAncestor(root.left, p, q)
    elif root.val < p.val and root.val < q.val:
        return lowestCommonAncestor(root.right, p, q)
    else:
        return root
```

**T.C.:** O(h)

**S.C.:** O(h)

**Quick Recall Hack:** “BST → check sides → root in between → LCA.”

---

### 8️⃣ Binary Tree Level Order Traversal \[Must Do]

**Pattern / Idea:**

* BFS using queue → append each level

**Python Code:**

```python
from collections import deque
def levelOrder(root):
    if not root:
        return []
    res = []
    queue = deque([root])
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
        res.append(level)
    return res
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** “BFS → one level at a time.”

---

### 9️⃣ Binary Tree Right Side View \[Must Do]

**Pattern / Idea:**

* BFS → take last node in each level

**Python Code:**

```python
from collections import deque
def rightSideView(root):
    if not root:
        return []
    res = []
    queue = deque([root])
    while queue:
        for i in range(len(queue)):
            node = queue.popleft()
            if i == len(queue) - 1:
                res.append(node.val)
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
    return res
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** “BFS → pick last in level.”

---

### 10️⃣ Count Good Nodes in Binary Tree \[Medium]

**Pattern / Idea:**

* DFS → pass max value seen from root → node.val ≥ max → good

**Python Code:**

```python
def goodNodes(root):
    def dfs(node, max_val):
        if not node:
            return 0
        count = 1 if node.val >= max_val else 0
        max_val = max(max_val, node.val)
        count += dfs(node.left, max_val)
        count += dfs(node.right, max_val)
        return count
    return dfs(root, root.val)
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “Pass max from root → count node ≥ max.”

---

### 11️⃣ Validate Binary Search Tree \[Must Do]

**Pattern / Idea:**

* DFS → check min/max bounds for each node

**Python Code:**

```python
def isValidBST(root):
    def dfs(node, low, high):
        if not node:
            return True
        if not (low < node.val < high):
            return False
        return dfs(node.left, low, node.val) and dfs(node.right, node.val, high)
    return dfs(root, float('-inf'), float('inf'))
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “BST → all left < node < all right.”

---

### 12️⃣ Kth Smallest Element in BST \[Must Do]

**Pattern / Idea:**

* Inorder traversal → sorted order → return kth element

**Python Code:**

```python
def kthSmallest(root, k):
    stack = []
    while True:
        while root:
            stack.append(root)
            root = root.left
        root = stack.pop()
        k -= 1
        if k == 0:
            return root.val
        root = root.right
```

**T.C.:** O(h + k)

**S.C.:** O(h)

**Quick Recall Hack:** “Inorder → kth element.”

---

### 13️⃣ Construct Binary Tree from Preorder and Inorder \[Medium-Hard]

**Pattern / Idea:**

* Preorder → root
* Inorder → left/right subtrees

**Python Code:**

```python
def buildTree(preorder, inorder):
    if not preorder or not inorder:
        return None
    root_val = preorder[0]
    root = TreeNode(root_val)
    idx = inorder.index(root_val)
    root.left = buildTree(preorder[1:1+idx], inorder[:idx])
    root.right = buildTree(preorder[1+idx:], inorder[idx+1:])
    return root
```

**T.C.:** O(n²) (can optimize with hashmap to O(n))

**S.C.:** O(n)

**Quick Recall Hack:** “Preorder first → split inorder → recurse left/right.”

---

### 14️⃣ Binary Tree Maximum Path Sum \[Hard]

**Pattern / Idea:**

* Recursive DFS → max path through node = left + right + node.val
* Track global max

**Python Code:**

```python
def maxPathSum(root):
    res = float('-inf')
    def dfs(node):
        nonlocal res
        if not node: return 0
        left = max(dfs(node.left), 0)
        right = max(dfs(node.right), 0)
        res = max(res, node.val + left + right)
        return node.val + max(left, right)
    dfs(root)
    return res
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “Return max single path, track max through node.”

---

### 15️⃣ Serialize and Deserialize Binary Tree \[Medium-Hard]

**Pattern / Idea:**

* Preorder traversal → store `None` as marker
* Reconstruct recursively

**Python Code:**

```python
def serialize(root):
    res = []
    def dfs(node):
        if not node:
            res.append('X')
            return
        res.append(str(node.val))
        dfs(node.left)
        dfs(node.right)
    dfs(root)
    return ','.join(res)

def deserialize(data):
    vals = iter(data.split(','))
    def dfs():
        val = next(vals)
        if val == 'X':
            return None
        node = TreeNode(int(val))
        node.left = dfs()
        node.right = dfs()
        return node
    return dfs()
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** “Preorder with null → reconstruct recursively.”






Perfect. Let’s move on to **Heap / Priority Queue** problems. These are **medium to hard in interviews**, but once you understand **min/max heap tricks**, they become very systematic. I’ll include **patterns, clear Python code, T.C./S.C., and quick interview cheats**.

---

# ** Section 12 : Heap / Priority Queue**

---

### 1️⃣ Kth Largest Element in a Stream \[Must Do]

**Pattern / Idea:**

* Maintain a **min-heap of size k** → top of heap is kth largest

**Python Code:**

```python
import heapq

class KthLargest:
    def __init__(self, k, nums):
        self.k = k
        self.heap = nums
        heapq.heapify(self.heap)
        while len(self.heap) > k:
            heapq.heappop(self.heap)

    def add(self, val):
        heapq.heappush(self.heap, val)
        if len(self.heap) > self.k:
            heapq.heappop(self.heap)
        return self.heap[0]
```

**T.C.:** O(log k) per add

**S.C.:** O(k)

**Quick Recall Hack:** “Min-heap size k → top = kth largest.”

---

### 2️⃣ Last Stone Weight \[Medium]

**Pattern / Idea:**

* Use **max-heap** → smash two largest stones each time

**Python Code:**

```python
import heapq

def lastStoneWeight(stones):
    stones = [-s for s in stones]  # max-heap
    heapq.heapify(stones)
    while len(stones) > 1:
        first = -heapq.heappop(stones)
        second = -heapq.heappop(stones)
        if first != second:
            heapq.heappush(stones, -(first - second))
    return -stones[0] if stones else 0
```

**T.C.:** O(n log n)

**S.C.:** O(n)

**Quick Recall Hack:** “Max-heap → smash top 2 → push remainder.”

---

### 3️⃣ K Closest Points to Origin \[Must Do]

**Pattern / Idea:**

* Use **max-heap of size k** based on distance² → keep closest k

**Python Code:**

```python
import heapq

def kClosest(points, k):
    heap = []
    for x, y in points:
        dist = -(x*x + y*y)
        if len(heap) < k:
            heapq.heappush(heap, (dist, x, y))
        else:
            heapq.heappushpop(heap, (dist, x, y))
    return [(x, y) for (_, x, y) in heap]
```

**T.C.:** O(n log k)

**S.C.:** O(k)

**Quick Recall Hack:** “Max-heap of size k → keep closest.”

---

### 4️⃣ Kth Largest Element in an Array \[Must Do]

**Pattern / Idea:**

* Same as Kth largest in stream → min-heap size k

**Python Code:**

```python
import heapq

def findKthLargest(nums, k):
    heap = nums[:k]
    heapq.heapify(heap)
    for num in nums[k:]:
        if num > heap[0]:
            heapq.heappushpop(heap, num)
    return heap[0]
```

**T.C.:** O(n log k)

**S.C.:** O(k)

**Quick Recall Hack:** “Min-heap size k → top = kth largest.”

---

### 5️⃣ Task Scheduler \[Medium-Hard]

**Pattern / Idea:**

* Use **max-heap for frequencies** + greedy scheduling

**Python Code:**

```python
from collections import Counter
import heapq

def leastInterval(tasks, n):
    freq = Counter(tasks)
    heap = [-cnt for cnt in freq.values()]
    heapq.heapify(heap)
    time = 0
    while heap:
        temp = []
        for _ in range(n + 1):
            if heap:
                temp.append(heapq.heappop(heap))
        for item in temp:
            if item + 1 < 0:
                heapq.heappush(heap, item + 1)
        time += n + 1 if heap else len(temp)
    return time
```

**T.C.:** O(t log 26) → t = number of tasks

**S.C.:** O(26)

**Quick Recall Hack:** “Max frequency first → schedule n+1 window.”

---

### 6️⃣ Design Twitter \[Hard]

**Pattern / Idea:**

* Use **heap** to merge recent posts from multiple users → get top 10

**Python Code (simplified feed):**

```python
import heapq
from collections import defaultdict

class Twitter:
    def __init__(self):
        self.time = 0
        self.tweets = defaultdict(list)
        self.followees = defaultdict(set)

    def postTweet(self, userId, tweetId):
        self.tweets[userId].append((self.time, tweetId))
        self.time -= 1  # decreasing to simulate max-heap by time

    def getNewsFeed(self, userId):
        heap = []
        self.followees[userId].add(userId)
        for uid in self.followees[userId]:
            for tweet in self.tweets[uid][-10:]:
                heapq.heappush(heap, tweet)
        return [tweetId for _, tweetId in heapq.nlargest(10, heap)]

    def follow(self, followerId, followeeId):
        self.followees[followerId].add(followeeId)

    def unfollow(self, followerId, followeeId):
        self.followees[followerId].discard(followeeId)
```

**T.C.:** O(n log 10) for feed

**S.C.:** O(n)

**Quick Recall Hack:** “Heap → merge recent posts → pick top 10.”

---

### 7️⃣ Find Median from Data Stream \[Hard]

**Pattern / Idea:**

* **Two heaps** → max-heap left, min-heap right → balance sizes

**Python Code:**

```python
import heapq

class MedianFinder:
    def __init__(self):
        self.low = []  # max-heap
        self.high = [] # min-heap

    def addNum(self, num):
        heapq.heappush(self.low, -num)
        heapq.heappush(self.high, -heapq.heappop(self.low))
        if len(self.low) < len(self.high):
            heapq.heappush(self.low, -heapq.heappop(self.high))

    def findMedian(self):
        if len(self.low) > len(self.high):
            return -self.low[0]
        return (-self.low[0] + self.high[0]) / 2
```

**T.C.:** O(log n) per add, O(1) median

**S.C.:** O(n)

**Quick Recall Hack:** “Two heaps → max left, min right → balance → median.”

---

### ✅ **Heap / Priority Queue Summary Cheats**

1. **Min-heap for kth largest** → keep heap size k
2. **Max-heap for largest elements or frequencies** → use `-val`
3. **Merge k sorted / recent posts** → heap to pick smallest/largest top efficiently
4. **Median → two heaps** → max-left, min-right → balance

---



