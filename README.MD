
# Table of Contents


## Section 1: Arrays & Hashing
- [Contains Duplicate [Must Do]](#contains-duplicate-must-do)
- [Valid Anagram](#valid-anagram)
- [Two Sum [Must Do]](#two-sum-must-do)
- [Group Anagrams [Must Do]](#group-anagrams-must-do)
- [Top K Frequent Elements [Must Do]](#top-k-frequent-elements-must-do)
- [Encode and Decode Strings](#encode-and-decode-strings)
- [Product of Array Except Self [Must Do]](#product-of-array-except-self-must-do)
- [Valid Sudoku [Must Do]](#valid-sudoku-must-do)
- [Longest Consecutive Sequence [Must Do]](#longest-consecutive-sequence-must-do)

## Section 2: Two Pointers
- [Valid Palindrome [Must Do]](#valid-palindrome-must-do)
- [Two Sum II – Input Array Is Sorted [Must Do]](#two-sum-ii-input-array-is-sorted-must-do)
- [3Sum [Must Do]](#3sum-must-do)
- [Container With Most Water [Must Do]](#container-with-most-water-must-do)
- [Trapping Rain Water [Must Do]](#trapping-rain-water-must-do)

## Section 3: Sliding Window
- [Best Time to Buy and Sell Stock [Must Do]](#best-time-to-buy-and-sell-stock-must-do)
- [Longest Substring Without Repeating Characters [Must Do]](#longest-substring-without-repeating-characters-must-do)
- [Longest Repeating Character Replacement [Must Do]](#longest-repeating-character-replacement-must-do)
- [Permutation in String [Must Do]](#permutation-in-string-must-do)
- [Minimum Window Substring [Must Do]](#minimum-window-substring-must-do)
- [Sliding Window Maximum [Must Do]](#sliding-window-maximum-must-do)

## Section 4: Stack
- [Valid Parentheses [Must Do]](#valid-parentheses-must-do)
- [Min Stack [Must Do]](#min-stack-must-do)
- [Evaluate Reverse Polish Notation [Must Do]](#evaluate-reverse-polish-notation-must-do)
- [Generate Parentheses [Must Do]](#generate-parentheses-must-do)
- [Daily Temperatures [Must Do]](#daily-temperatures-must-do)
- [Car Fleet](#car-fleet)
- [Largest Rectangle in Histogram [Must Do]](#largest-rectangle-in-histogram-must-do)

## Section 5: Binary Search
- [Binary Search [Must Do]](#binary-search-must-do)
- [Search a 2D Matrix [Must Do]](#search-a-2d-matrix-must-do)
- [Koko Eating Bananas [Must Do]](#koko-eating-bananas-must-do)
- [Find Minimum in Rotated Sorted Array [Must Do]](#find-minimum-in-rotated-sorted-array-must-do)
- [Search in Rotated Sorted Array [Must Do]](#search-in-rotated-sorted-array-must-do)
- [Time-Based Key Value Store [Must Do]](#time-based-key-value-store-must-do)

## Section 6: Greedy
- [Maximum Subarray [Must Do]](#maximum-subarray-must-do)
- [Jump Game [Must Do]](#jump-game-must-do)
- [Jump Game II [Must Do]](#jump-game-ii-must-do)
- [Gas Station [Must Do]](#gas-station-must-do)
- [Hand of Straights](#hand-of-straights)
- [Merge Triplets to Form Target Triplet](#merge-triplets-to-form-target-triplet)
- [Partition Labels](#partition-labels)
- [Valid Parenthesis String](#valid-parenthesis-string)

## Section 7: Intervals
- [Insert Interval [Must Do]](#insert-interval-must-do)
- [Merge Intervals [Must Do]](#merge-intervals-must-do)
- [Non-Overlapping Intervals [Must Do]](#non-overlapping-intervals-must-do)
- [Meeting Rooms](#meeting-rooms)
- [Meeting Rooms II [Must Do]](#meeting-rooms-ii-must-do)
- [Minimum Interval to Include Each Query](#minimum-interval-to-include-each-query)

## Section 8: Math & Geometry
- [Rotate Image [Must Do]](#rotate-image-must-do)
- [Spiral Matrix [Must Do]](#spiral-matrix-must-do)
- [Set Matrix Zeroes [Must Do]](#set-matrix-zeroes-must-do)
- [Happy Number [Must Do]](#happy-number-must-do)
- [Plus One [Must Do]](#plus-one-must-do)
- [Pow(x, n) [Must Do]](#powx-n-must-do)
- [Multiply Strings [Must Do]](#multiply-strings-must-do)
- [Detect Squares](#detect-squares)
- [Detect Triangles [Must Do]](#detect-triangles-must-do)

## Section 9: Bit Manipulation
- [Single Number [Must Do]](#single-number-must-do)
- [Number of 1 Bits [Must Do]](#number-of-1-bits-must-do)
- [Counting Bits [Must Do]](#counting-bits-must-do)
- [Reverse Bits [Must Do]](#reverse-bits-must-do)
- [Missing Number [Must Do]](#missing-number-must-do)
- [Sum of Two Integers [Must Do]](#sum-of-two-integers-must-do)
- [Reverse Integer [Must Do]](#reverse-integer-must-do)

## Section 10: Linked List
- [Reverse Linked List [Must Do]](#reverse-linked-list-must-do)
- [Merge Two Sorted Lists [Must Do]](#merge-two-sorted-lists-must-do)
- [Linked List Cycle [Must Do]](#linked-list-cycle-must-do)
- [Reorder List [Must Do]](#reorder-list-must-do)
- [Remove Nth Node From End [Must Do]](#remove-nth-node-from-end-must-do)
- [Copy List With Random Pointer [Must Do]](#copy-list-with-random-pointer-must-do)
- [Add Two Numbers [Must Do]](#add-two-numbers-must-do)
- [Find the Duplicate Number [Must Do]](#find-the-duplicate-number-must-do)
- [LRU Cache [Must Do]](#lru-cache-must-do)
- [Merge K Sorted Lists [Must Do]](#merge-k-sorted-lists-must-do)
- [Reverse Nodes in k-Group [Must Do]](#reverse-nodes-in-k-group-must-do)

## Section 11: Trees
- [Invert Binary Tree [Must Do]](#invert-binary-tree-must-do)
- [Maximum Depth of Binary Tree [Must Do]](#maximum-depth-of-binary-tree-must-do)
- [Diameter of Binary Tree [Must Do]](#diameter-of-binary-tree-must-do)
- [Balanced Binary Tree [Must Do]](#balanced-binary-tree-must-do)
- [Same Tree [Must Do]](#same-tree-must-do)
- [Subtree of Another Tree [Must Do]](#subtree-of-another-tree-must-do)
- [Lowest Common Ancestor of BST [Must Do]](#lowest-common-ancestor-of-bst-must-do)
- [Binary Tree Level Order Traversal [Must Do]](#binary-tree-level-order-traversal-must-do)
- [Binary Tree Right Side View [Must Do]](#binary-tree-right-side-view-must-do)
- [Count Good Nodes in Binary Tree](#count-good-nodes-in-binary-tree)
- [Validate Binary Search Tree [Must Do]](#validate-binary-search-tree-must-do)
- [Kth Smallest Element in BST [Must Do]](#kth-smallest-element-in-bst-must-do)
- [Construct Binary Tree from Preorder and Inorder](#construct-binary-tree-from-preorder-and-inorder)
- [Binary Tree Maximum Path Sum](#binary-tree-maximum-path-sum)
- [Serialize and Deserialize Binary Tree](#serialize-and-deserialize-binary-tree)
- [Binary Tree Zigzag Level Order Traversal](#binary-tree-zigzag-level-order-traversal)
- [Serialize and Deserialize BST](#serialize-and-deserialize-bst)

## Section 12: Heap / Priority Queue
- [Kth Largest Element in a Stream [Must Do]](#kth-largest-element-in-a-stream-must-do)
- [Last Stone Weight](#last-stone-weight)
- [K Closest Points to Origin [Must Do]](#k-closest-points-to-origin-must-do)
- [Kth Largest Element in an Array [Must Do]](#kth-largest-element-in-an-array-must-do)
- [Task Scheduler](#task-scheduler)
- [Design Twitter](#design-twitter)
- [Find Median from Data Stream](#find-median-from-data-stream)

## Section 13: Graphs
- [Number of Islands [Must Do]](#number-of-islands-must-do)
- [Max Area of Island [Must Do]](#max-area-of-island-must-do)
- [Clone Graph [Must Do]](#clone-graph-must-do)
- [Walls and Gates [Must Do]](#walls-and-gates-must-do)
- [Rotting Oranges [Must Do]](#rotting-oranges-must-do)
- [Pacific Atlantic Water Flow [Must Do]](#pacific-atlantic-water-flow-must-do)
- [Surrounded Regions [Must Do]](#surrounded-regions-must-do)
- [Course Schedule (Topological Sort) [Must Do]](#course-schedule-topological-sort-must-do)
- [Course Schedule II [Must Do]](#course-schedule-ii-must-do)
- [Graph Valid Tree [Must Do]](#graph-valid-tree-must-do)
- [Number of Connected Components [Must Do]](#number-of-connected-components-must-do)
- [Redundant Connection [Must Do]](#redundant-connection-must-do)
- [Word Ladder [Must Do]](#word-ladder-must-do)

## Section 14: 1-D Dynamic Programming
- [Climbing Stairs [Must Do]](#climbing-stairs-must-do)
- [Min Cost Climbing Stairs [Must Do]](#min-cost-climbing-stairs-must-do)
- [House Robber [Must Do]](#house-robber-must-do)
- [House Robber II](#house-robber-ii)
- [Longest Palindromic Substring [Must Do]](#longest-palindromic-substring-must-do)
- [Palindromic Substrings](#palindromic-substrings)
- [Decode Ways [Must Do]](#decode-ways-must-do)
- [Coin Change [Must Do]](#coin-change-must-do)
- [Maximum Product Subarray](#maximum-product-subarray)
- [Word Break [Must Do]](#word-break-must-do)
- [Longest Increasing Subsequence [Must Do]](#longest-increasing-subsequence-must-do)
- [Partition Equal Subset Sum [Must Do]](#partition-equal-subset-sum-must-do)

## Section 15: 2-D Dynamic Programming
- [Unique Paths [Must Do]](#unique-paths-must-do)
- [Longest Common Subsequence [Must Do]](#longest-common-subsequence-must-do)
- [Best Time to Buy and Sell Stock with Cooldown [Must Do]](#best-time-to-buy-and-sell-stock-with-cooldown-must-do)
- [Coin Change II [Must Do]](#coin-change-ii-must-do)
- [Target Sum [Must Do]](#target-sum-must-do)
- [Interleaving String [Must Do]](#interleaving-string-must-do)
- [Longest Increasing Path in a Matrix [Must Do]](#longest-increasing-path-in-a-matrix-must-do)
- [Distinct Subsequences [Must Do]](#distinct-subsequences-must-do)
- [Edit Distance [Must Do]](#edit-distance-must-do)
- [Burst Balloons [Must Do]](#burst-balloons-must-do)
- [Regular Expression Matching [Must Do]](#regular-expression-matching-must-do)







---
Go to [Computer Networks](#computer-networks) section for detailed notes.


---

---
[Rest of the subjects Revision](#other-subjects-revision)
---

## Section 1: Arrays & Hashing

---

### 1️⃣ Contains Duplicate \[Must Do]

**Pattern / Idea:** Use a set to track seen elements. If a number repeats, return True.

**Pseudocode:**

* Initialize empty set `seen`
* For each number `n` in array:

  * If `n` in `seen`, return True
  * Else, add `n` to `seen`
* Return False

**Python Code:**

```python
def containsDuplicate(nums):
    seen = set()
    for n in nums:
        if n in seen:
            return True
        seen.add(n)
    return False
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Set = guard against repeats."

---

### 2️⃣ Valid Anagram

**Pattern / Idea:** Count characters in both strings and compare.

**Pseudocode:**

* If lengths differ → False
* Count characters in both strings
* Compare counts

**Python Code:**

```python
from collections import Counter
def isAnagram(s, t):
    return Counter(s) == Counter(t)
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Same letters, same count."

---

### 3️⃣ Two Sum \[Must Do]

**Pattern / Idea:** Use hash map to store numbers and look for complement.

**Pseudocode:**

* Initialize empty dictionary `d`
* For each index i, num in nums:

  * If target - num in d → return \[d\[target-num], i]
  * Else, store num in d with index

**Python Code:**

```python
def twoSum(nums, target):
    d = {}
    for i, num in enumerate(nums):
        if target - num in d:
            return [d[target - num], i]
        d[num] = i
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Store, check, return."

---

### 4️⃣ Group Anagrams \[Must Do]

**Pattern / Idea:** Strings with same sorted characters belong together. Use hash map.

**Pseudocode:**

* Initialize `groups = defaultdict(list)`
* For each string `s` in strs:

  * Key = sorted(s) → join back to string
  * Append s to `groups[key]`
* Return all groups

**Python Code:**

```python
from collections import defaultdict
def groupAnagrams(strs):
    groups = defaultdict(list)
    for s in strs:
        key = ''.join(sorted(s))
        groups[key].append(s)
    return list(groups.values())
```

**T.C.:** O(n k log k) → n = #strings, k = avg length

**S.C.:** O(n k)

**Quick Recall Hack:** "Sort letters → group."

---

### 5️⃣ Top K Frequent Elements \[Must Do]

**Pattern / Idea:** Count frequency → use heap or bucket sort.

**Pseudocode:**

* Count elements using Counter
* Sort elements by frequency
* Return top K

**Python Code:**

```python
from collections import Counter
def topKFrequent(nums, k):
    count = Counter(nums)
    return [item for item, freq in count.most_common(k)]
```

**T.C.:** O(n log k)

**S.C.:** O(n)

**Quick Recall Hack:** "Count → top K."

---

### 6️⃣ Encode and Decode Strings

**Pattern / Idea:** Encode using delimiter; decode by splitting.

**Pseudocode:**

* Encode: append length + '#' + string
* Decode: parse length, extract substring

**Python Code:**

```python
def encode(strs):
    return ''.join(f'{len(s)}#{s}' for s in strs)

def decode(s):
    res, i = [], 0
    while i < len(s):
        j = i
        while s[j] != '#':
            j += 1
        length = int(s[i:j])
        res.append(s[j+1:j+1+length])
        i = j + 1 + length
    return res
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Length#String → easy parse."

---

### 7️⃣ Product of Array Except Self \[Must Do]

**Pattern / Idea:** Prefix & suffix product arrays.

**Pseudocode:**

* Left product: accumulate from start
* Right product: accumulate from end
* Multiply left\[i] \* right\[i]

**Python Code:**

```python
def productExceptSelf(nums):
    n = len(nums)
    res = [1]*n
    prefix = 1
    for i in range(n):
        res[i] = prefix
        prefix *= nums[i]
    suffix = 1
    for i in range(n-1, -1, -1):
        res[i] *= suffix
        suffix *= nums[i]
    return res
```

**T.C.:** O(n)

**S.C.:** O(1) extra (res counts)

**Quick Recall Hack:** "Prefix \* Suffix = answer."

---

### 8️⃣ Valid Sudoku \[Must Do]

**Pattern / Idea:** Check rows, columns, and 3x3 blocks for duplicates.

**Pseudocode:**

* For each row, col, block:

  * Maintain set
  * If duplicate → False
* Else → True

**Python Code:**

```python
def isValidSudoku(board):
    rows = [set() for _ in range(9)]
    cols = [set() for _ in range(9)]
    boxes = [set() for _ in range(9)]
    for i in range(9):
        for j in range(9):
            num = board[i][j]
            if num == '.':
                continue
            if num in rows[i] or num in cols[j] or num in boxes[(i//3)*3 + j//3]:
                return False
            rows[i].add(num)
            cols[j].add(num)
            boxes[(i//3)*3 + j//3].add(num)
    return True
```

**T.C.:** O(1) → board fixed size

**S.C.:** O(1)

**Quick Recall Hack:** "Row+Col+Box sets."

---

### 9️⃣ Longest Consecutive Sequence \[Must Do]

**Pattern / Idea:** Use a set to expand sequences from sequence starts.

**Pseudocode:**

* Put nums in set
* For each num:

  * If num-1 not in set → start sequence
  * Count consecutive numbers
  * Track max length

**Python Code:**

```python
def longestConsecutive(nums):
    num_set = set(nums)
    max_len = 0
    for n in num_set:
        if n-1 not in num_set:
            length = 1
            while n+length in num_set:
                length += 1
            max_len = max(max_len, length)
    return max_len
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Sequence start → expand."




---

## Section 2: Two Pointers

---

### 1️⃣ Valid Palindrome \[Must Do]

**Pattern / Idea:** Use two pointers from start and end; skip non-alphanumeric.

**Pseudocode:**

* i = 0, j = len(s)-1
* While i < j:

  * If s\[i] not alnum → i++
  * If s\[j] not alnum → j--
  * If s\[i].lower() != s\[j].lower() → return False
  * Else i++, j--
* Return True

**Python Code:**

```python
def isPalindrome(s):
    i, j = 0, len(s)-1
    while i < j:
        while i < j and not s[i].isalnum():
            i += 1
        while i < j and not s[j].isalnum():
            j -= 1
        if s[i].lower() != s[j].lower():
            return False
        i += 1
        j -= 1
    return True
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Skip junk → match ends."

---

### 2️⃣ Two Sum II – Input Array Is Sorted \[Must Do]

**Pattern / Idea:** Sorted array → two pointers from ends.

**Pseudocode:**

* i = 0, j = len(nums)-1
* While i < j:

  * sum = nums\[i] + nums\[j]
  * If sum == target → return \[i+1, j+1]
  * If sum < target → i++
  * Else → j--

**Python Code:**

```python
def twoSumSorted(nums, target):
    i, j = 0, len(nums)-1
    while i < j:
        s = nums[i] + nums[j]
        if s == target:
            return [i+1, j+1]
        elif s < target:
            i += 1
        else:
            j -= 1
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Sum too small → right up, too big → left down."

---

### 3️⃣ 3Sum \[Must Do]

**Pattern / Idea:** Sort array → fix one element → two pointers for remaining two.

**Pseudocode:**

* Sort nums
* For i in range(n):

  * Skip duplicates
  * left=i+1, right=n-1
  * While left < right:

    * total = nums\[i]+nums\[left]+nums\[right]
    * If total == 0 → add triplet, left++, right-- (skip duplicates)
    * If total < 0 → left++
    * Else → right--

**Python Code:**

```python
def threeSum(nums):
    nums.sort()
    res = []
    for i in range(len(nums)):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        left, right = i+1, len(nums)-1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                res.append([nums[i], nums[left], nums[right]])
                left += 1
                right -= 1
                while left < right and nums[left] == nums[left-1]:
                    left += 1
                while left < right and nums[right] == nums[right+1]:
                    right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    return res
```

**T.C.:** O(n²)

**S.C.:** O(n)

**Quick Recall Hack:** "Sort + fix one + two pointers."

---

### 4️⃣ Container With Most Water \[Must Do]

**Pattern / Idea:** Two pointers → maximize area = min(height) \* width.

**Pseudocode:**

* left=0, right=n-1, max\_area=0
* While left < right:

  * area = min(height\[left], height\[right])\*(right-left)
  * Update max\_area
  * Move smaller height pointer

**Python Code:**

```python
def maxArea(height):
    left, right = 0, len(height)-1
    max_area = 0
    while left < right:
        max_area = max(max_area, min(height[left], height[right])*(right-left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Move smaller → potential increase."

---

### 5️⃣ Trapping Rain Water \[Must Do]

**Pattern / Idea:** Two pointers → track left\_max and right\_max → water = min(left\_max, right\_max)-height.

**Pseudocode:**

* left=0, right=n-1, left\_max=0, right\_max=0, water=0
* While left < right:

  * If height\[left] < height\[right]:

    * left\_max = max(left\_max, height\[left])
    * water += left\_max - height\[left]
    * left++
  * Else:

    * right\_max = max(right\_max, height\[right])
    * water += right\_max - height\[right]
    * right--

**Python Code:**

```python
def trap(height):
    left, right = 0, len(height)-1
    left_max = right_max = water = 0
    while left < right:
        if height[left] < height[right]:
            left_max = max(left_max, height[left])
            water += left_max - height[left]
            left += 1
        else:
            right_max = max(right_max, height[right])
            water += right_max - height[right]
            right -= 1
    return water
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Two sides → trap water."

---



---

## Section 3: Sliding Window

---

### 1️⃣ Best Time to Buy and Sell Stock \[Must Do]

**Pattern / Idea:** Track the minimum price so far. Maximum profit = current price - min price.

* You don’t need nested loops; just one pass.


**Pseudocode:**

* Initialize `min_price = inf`, `max_profit = 0`
* For each price in prices:

  * Update min\_price = min(min\_price, price)
  * Update max\_profit = max(max\_profit, price - min\_price)
* Return max\_profit

**Python Code:**

```python
def maxProfit(prices):
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Track min, update profit."

---

### 2️⃣ Longest Substring Without Repeating Characters \[Must Do]

**Pattern / Idea:** Sliding window → expand window until repeat → shrink from left.

* Use set to check duplicates.


**Pseudocode:**

* left=0, max\_len=0, seen=set()
* For right in range(len(s)):

  * While s\[right] in seen:

    * Remove s\[left] from set
    * left +=1
  * Add s\[right] to set
  * Update max\_len = max(max\_len, right-left+1)

**Python Code:**

```python
def lengthOfLongestSubstring(s):
    seen = set()
    left = 0
    max_len = 0
    for right in range(len(s)):
        while s[right] in seen:
            seen.remove(s[left])
            left += 1
        seen.add(s[right])
        max_len = max(max_len, right-left+1)
    return max_len
```

**T.C.:** O(n)

**S.C.:** O(min(n, charset))

**Quick Recall Hack:** "Expand → shrink when repeat."

---

### 3️⃣ Longest Repeating Character Replacement \[Must Do]

**Pattern / Idea:** Sliding window → keep track of most frequent char in window.

* Max length window = window size - max\_freq ≤ k


**Pseudocode:**

* left=0, count={}
* max\_count=0, max\_len=0
* For right in range(len(s)):

  * count\[s\[right]] +=1
  * max\_count = max(max\_count, count\[s\[right]])
  * If window\_size - max\_count > k → remove s\[left], left++
  * Update max\_len

**Python Code:**

```python
def characterReplacement(s, k):
    count = {}
    left = max_count = max_len = 0
    for right in range(len(s)):
        count[s[right]] = count.get(s[right], 0) + 1
        max_count = max(max_count, count[s[right]])
        while (right - left + 1) - max_count > k:
            count[s[left]] -= 1
            left += 1
        max_len = max(max_len, right - left + 1)
    return max_len
```

**T.C.:** O(n)

**S.C.:** O(26) → English letters

**Quick Recall Hack:** "Window - max freq ≤ k → shrink."

---

### 4️⃣ Permutation in String \[Must Do]

**Pattern / Idea:** Check if a window in s2 is a permutation of s1.

* Fixed window size = len(s1), check counts match.


**Pseudocode:**

* Build freq of s1
* Slide window of size len(s1) over s2
* Keep freq of current window
* If matches → True

**Python Code:**

```python
from collections import Counter
def checkInclusion(s1, s2):
    len1 = len(s1)
    s1_count = Counter(s1)
    window_count = Counter()
    for i in range(len(s2)):
        window_count[s2[i]] += 1
        if i >= len1:
            if window_count[s2[i - len1]] == 1:
                del window_count[s2[i - len1]]
            else:
                window_count[s2[i - len1]] -= 1
        if window_count == s1_count:
            return True
    return False
```

**T.C.:** O(n)

**S.C.:** O(26) → letters

**Quick Recall Hack:** "Slide window, compare counts."

---

### 5️⃣ Minimum Window Substring \[Must Do]

**Pattern / Idea:** Sliding window → include all chars of t, shrink left as much as possible.

* Keep counts of t, compare with window counts.


**Pseudocode:**

* Build count\_t = Counter(t)
* left=0, formed=0, window\_counts={}
* Expand right: add s\[right] to window\_counts
* While window satisfies t:

  * update min\_len, min\_start
  * remove s\[left] from window\_counts, left++
* Return substring

**Python Code:**

```python
from collections import Counter
def minWindow(s, t):
    if not t or not s:
        return ""
    count_t = Counter(t)
    window_counts = {}
    have = 0
    need = len(count_t)
    res = [float("inf"), 0, 0]  # length, start, end
    left = 0
    for right, char in enumerate(s):
        window_counts[char] = window_counts.get(char, 0) + 1
        if char in count_t and window_counts[char] == count_t[char]:
            have += 1
        while have == need:
            if right - left + 1 < res[0]:
                res = [right - left + 1, left, right]
            window_counts[s[left]] -= 1
            if s[left] in count_t and window_counts[s[left]] < count_t[s[left]]:
                have -= 1
            left += 1
    l = res[1]
    r = res[2]
    return s[l:r+1] if res[0] != float("inf") else ""
```

**T.C.:** O(n + m) → n=len(s), m=len(t)

**S.C.:** O(26) → letters

**Quick Recall Hack:** "Expand to satisfy, shrink to minimize."

---

### 6️⃣ Sliding Window Maximum \[Must Do]

**Pattern / Idea:** Use deque to maintain decreasing elements → max at deque\[0].

* Remove smaller elements from back.


**Pseudocode:**

* Initialize deque
* For i in range(len(nums)):

  * Remove indices out of window
  * Remove indices whose nums < nums\[i] from back
  * Append i
  * If i >= k-1 → res.append(nums\[deque\[0]])

**Python Code:**

```python
from collections import deque
def maxSlidingWindow(nums, k):
    dq = deque()
    res = []
    for i, n in enumerate(nums):
        while dq and dq[0] <= i - k:
            dq.popleft()
        while dq and nums[dq[-1]] < n:
            dq.pop()
        dq.append(i)
        if i >= k - 1:
            res.append(nums[dq[0]])
    return res
```

**T.C.:** O(n)

**S.C.:** O(k)

**Quick Recall Hack:** "Deque keeps max at front."

---



Perfect. Let’s tackle the **Stack** section with **ultra-clear cheats to memorize**, step-by-step logic, simple Python code, T.C., S.C., and quick mental hacks. I’ll mark **must-do non-FAANG problems** in brackets.

---

## Section 4: Stack

---

### 1️⃣ Valid Parentheses \[Must Do]

**Pattern / Idea:** Use a stack to track opening brackets; match when closing appears.

**Pseudocode:**

* Initialize empty stack
* For each char:

  * If opening → push
  * If closing → check top of stack matches, else False
* Return True if stack empty

**Python Code:**

```python
def isValid(s):
    stack = []
    mapping = {')':'(', '}':'{', ']':'['}
    for char in s:
        if char in mapping.values():
            stack.append(char)
        else:
            if not stack or stack[-1] != mapping[char]:
                return False
            stack.pop()
    return not stack
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Push opens, pop matches → empty = valid."

**Cheat to memorize:** “Stack = open → push, close → pop.”

---

### 2️⃣ Min Stack \[Must Do]

**Pattern / Idea:** Use auxiliary stack to track min values.

**Pseudocode:**

* main stack: store values
* min stack: store min so far
* Push: push val; push min(val, min\_stack\[-1]) to min\_stack
* Pop: pop both stacks
* Top: return stack\[-1]
* GetMin: return min\_stack\[-1]

**Python Code:**

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val):
        self.stack.append(val)
        if not self.min_stack:
            self.min_stack.append(val)
        else:
            self.min_stack.append(min(val, self.min_stack[-1]))

    def pop(self):
        self.stack.pop()
        self.min_stack.pop()

    def top(self):
        return self.stack[-1]

    def getMin(self):
        return self.min_stack[-1]
```

**T.C.:** O(1) for all operations

**S.C.:** O(n)

**Quick Recall Hack:** "Track min alongside main stack."

**Cheat to memorize:** “Double stack = fast min.”

---

### 3️⃣ Evaluate Reverse Polish Notation \[Must Do]

**Pattern / Idea:** Use stack → push numbers, pop two for operator, push result.

**Pseudocode:**

* Initialize stack
* For each token:

  * If number → push
  * If operator → pop a,b → push b op a
* Return stack\[0]

**Python Code:**

```python
def evalRPN(tokens):
    stack = []
    for t in tokens:
        if t not in "+-*/":
            stack.append(int(t))
        else:
            b = stack.pop()
            a = stack.pop()
            if t == '+': stack.append(a+b)
            elif t == '-': stack.append(a-b)
            elif t == '*': stack.append(a*b)
            else: stack.append(int(a/b))  # truncate toward 0
    return stack[0]
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Numbers push, operator → pop 2 → push result."

**Cheat to memorize:** “Stack = compute on pop.”

---

### 4️⃣ Generate Parentheses \[Must Do]

**Pattern / Idea:** Backtracking → only add '(' if left\<n, only add ')' if right\<left.

**Pseudocode:**

* Recursive function(path, left, right):

  * If len(path)=2n → add path
  * If left\<n → recurse(path+'(', left+1, right)
  * If right\<left → recurse(path+')', left, right+1)

**Python Code:**

```python
def generateParenthesis(n):
    res = []
    def backtrack(path, left, right):
        if len(path) == 2*n:
            res.append(path)
            return
        if left < n:
            backtrack(path+'(', left+1, right)
        if right < left:
            backtrack(path+')', left, right+1)
    backtrack('',0,0)
    return res
```

**T.C.:** O(4^n / √n)

**S.C.:** O(n) recursion

**Quick Recall Hack:** "Left\<n → add (, right\<left → add )"

**Cheat to memorize:** “Only valid opens & closes → recurse.”

---

### 5️⃣ Daily Temperatures \[Must Do]

**Pattern / Idea:** Monotonic decreasing stack → for each temp, pop lower → assign days.

**Pseudocode:**

* Initialize stack = \[]
* For i in range(len(T)):

  * While stack and T\[i] > T\[stack\[-1]]:

    * idx = stack.pop() → res\[idx] = i - idx
  * Push i

**Python Code:**

```python
def dailyTemperatures(T):
    res = [0]*len(T)
    stack = []
    for i, t in enumerate(T):
        while stack and t > T[stack[-1]]:
            idx = stack.pop()
            res[idx] = i - idx
        stack.append(i)
    return res
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Stack stores indices of decreasing temps."

**Cheat to memorize:** “Pop smaller → record days → push current.”

---

### 6️⃣ Car Fleet

**Pattern / Idea:** Sort by position → stack for arrival times → merge fleets.

**Pseudocode:**

* Sort cars by position descending
* For each car: compute time to target
* If time > top of stack → push
* Else → merge

**Python Code:**

```python
def carFleet(target, position, speed):
    cars = sorted(zip(position, speed), reverse=True)
    stack = []
    for p, s in cars:
        t = (target - p)/s
        if not stack or t > stack[-1]:
            stack.append(t)
    return len(stack)
```

**T.C.:** O(n log n)

**S.C.:** O(n)

**Quick Recall Hack:** "Sort → push if slower → else merge."

---

### 7️⃣ Largest Rectangle in Histogram \[Must Do]

**Pattern / Idea:** Monotonic stack → previous smaller → next smaller → width\*height.

**Pseudocode:**

* Append 0 to heights for final flush
* Stack = \[]
* For i in range(len(heights)):

  * While stack and heights\[i] < heights\[stack\[-1]]:

    * h = heights\[stack.pop()]
    * width = i - stack\[-1] - 1 if stack else i
    * update max\_area
  * Append i

**Python Code:**

```python
def largestRectangleArea(heights):
    heights.append(0)
    stack = []
    max_area = 0
    for i, h in enumerate(heights):
        while stack and h < heights[stack[-1]]:
            height = heights[stack.pop()]
            width = i - stack[-1] - 1 if stack else i
            max_area = max(max_area, height*width)
        stack.append(i)
    return max_area
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Stack stores indices → pop smaller → compute area."

**Cheat to memorize:** “Push increasing → pop smaller → area calc.”

---



Perfect. Let’s tackle the **Binary Search** section with **clear step-by-step logic, simple Python code, T.C., S.C., and easy-to-memorize cheats**. I’ll mark **must-do non-FAANG problems** in brackets.

---

## Section 5: Binary Search

---

### 1️⃣ Binary Search \[Must Do]

**Pattern / Idea:** Standard search in sorted array.

**Pseudocode:**

* left = 0, right = n-1
* While left ≤ right:

  * mid = left + (right-left)//2
  * If nums\[mid] == target → return mid
  * If nums\[mid] < target → left = mid+1
  * Else → right = mid-1
* Return -1

**Python Code:**

```python
def binarySearch(nums, target):
    left, right = 0, len(nums)-1
    while left <= right:
        mid = left + (right-left)//2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid+1
        else:
            right = mid-1
    return -1
```

**T.C.:** O(log n)

**S.C.:** O(1)

**Quick Recall Hack:** "Check mid → move left/right."

**Cheat to memorize:** “Divide & conquer → halve each time.”

---

### 2️⃣ Search a 2D Matrix \[Must Do]

**Pattern / Idea:** Treat 2D matrix as 1D sorted array → binary search.

**Pseudocode:**

* rows = len(matrix), cols = len(matrix\[0])
* left = 0, right = rows\*cols-1
* While left ≤ right:

  * mid = (left+right)//2
  * val = matrix\[mid//cols]\[mid%cols]
  * Compare val with target → adjust left/right

**Python Code:**

```python
def searchMatrix(matrix, target):
    if not matrix: return False
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows*cols - 1
    while left <= right:
        mid = (left + right)//2
        val = matrix[mid//cols][mid%cols]
        if val == target:
            return True
        elif val < target:
            left = mid + 1
        else:
            right = mid - 1
    return False
```

**T.C.:** O(log(m*n))

**S.C.:** O(1)

**Quick Recall Hack:** "1D index = row*cols + col."

---

### 3️⃣ Koko Eating Bananas \[Must Do]

**Pattern / Idea:** Binary search on rate → check if possible in given hours.

**Pseudocode:**

* left = 1, right = max(piles)
* While left ≤ right:

  * mid = (left+right)//2 → current rate
  * If canEat(mid) → right = mid-1
  * Else → left = mid+1
* Return left

**Python Code:**

```python
def minEatingSpeed(piles, H):
    def canEat(rate):
        hours = sum((p + rate - 1)//rate for p in piles)
        return hours <= H

    left, right = 1, max(piles)
    while left <= right:
        mid = (left + right)//2
        if canEat(mid):
            right = mid - 1
        else:
            left = mid + 1
    return left
```

**T.C.:** O(n log max(pile))

**S.C.:** O(1)

**Quick Recall Hack:** "Binary search → rate → feasible?"

---

### 4️⃣ Find Minimum in Rotated Sorted Array \[Must Do]

**Pattern / Idea:** Binary search → check mid vs right → decide left/right.

**Pseudocode:**

* left=0, right=n-1
* While left\<right:

  * mid = (left+right)//2
  * If nums\[mid] > nums\[right] → left = mid+1
  * Else → right = mid
* Return nums\[left]

**Python Code:**

```python
def findMin(nums):
    left, right = 0, len(nums)-1
    while left < right:
        mid = (left + right)//2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

**T.C.:** O(log n)

**S.C.:** O(1)

**Quick Recall Hack:** "Compare mid with right → move smaller side."

---

### 5️⃣ Search in Rotated Sorted Array \[Must Do]

**Pattern / Idea:** Binary search → check which half is sorted → adjust left/right.

**Pseudocode:**

* left=0, right=n-1
* While left ≤ right:

  * mid=(left+right)//2
  * If nums\[mid]==target → return mid
  * If nums\[left] ≤ nums\[mid]:

    * If left ≤ target < mid → right=mid-1
    * Else → left=mid+1
  * Else:

    * If mid < target ≤ right → left=mid+1
    * Else → right=mid-1
* Return -1

**Python Code:**

```python
def search(nums, target):
    left, right = 0, len(nums)-1
    while left <= right:
        mid = (left + right)//2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid-1
            else:
                left = mid+1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid+1
            else:
                right = mid-1
    return -1
```

**T.C.:** O(log n)

**S.C.:** O(1)

**Quick Recall Hack:** "Find sorted half → decide side."


---

### 6️⃣ Time-Based Key Value Store \[Must Do]

**Pattern / Idea:** Store times sorted → binary search latest ≤ query.

**Pseudocode:**

* Use dictionary: key → list of (time, value)
* Set: append (time,value)
* Get: binary search last time ≤ query

**Python Code:**

```python
from collections import defaultdict
import bisect

class TimeMap:
    def __init__(self):
        self.store = defaultdict(list)

    def set(self, key, value, timestamp):
        self.store[key].append((timestamp, value))

    def get(self, key, timestamp):
        items = self.store.get(key, [])
        i = bisect.bisect_right(items, (timestamp, chr(127)))
        return items[i-1][1] if i else ""
```

**T.C.:** O(log n) for get

**S.C.:** O(n)

**Quick Recall Hack:** "Binary search in timestamp list."

---



Perfect. Here's the **updated Greedy section** with your version of **Maximum Subarray** included, keeping everything clear, concise, and with cheat codes for memorization.

---

## Section 6: Greedy

---

### 1️⃣ Maximum Subarray \[Must Do]

**Pattern / Idea:** Kadane’s Algorithm → if running sum < 0, reset to 0; otherwise, add current number. Track maximum sum seen so far.

**Pseudocode:**

* res = nums\[0], total = nums\[0]
* For each num in nums\[1:]:

  * If total < 0 → reset total = 0
  * total += num
  * res = max(res, total)
* Return res

**Python Code:**

```python
from typing import List

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = nums[0]
        total = nums[0]
        for num in nums[1:]:
            if total < 0:
                total = 0
            total += num
            res = max(res, total)
        return res
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Reset if sum <0, else add → track max."

**Cheat to memorize:** “Kadane = reset bad sum, keep running max.”

### OR


**Maximum subarray sum = max(current_sum, max_sum).**

**Pseudocode:**

max_sum = current_sum = nums[0]

For i in 1 to n-1:

current_sum = max(nums[i], current_sum + nums[i])

max_sum = max(max_sum, current_sum)

Return max_sum

Python Code:
```python
def maxSubArray(nums):
    max_sum = current_sum = nums[0]
    for n in nums[1:]:
        current_sum = max(n, current_sum + n)
        max_sum = max(max_sum, current_sum)
    return max_sum
```

T.C.: O(n)

S.C.: O(1)

Quick Recall Hack: "Add if helps, reset if hurts."

---

### 2️⃣ Jump Game \[Must Do]

**Pattern / Idea:** Track farthest reachable index → if i > farthest → False.

**Pseudocode:**

* max\_reach = 0
* For i in range(len(nums)):

  * If i > max\_reach → return False
  * max\_reach = max(max\_reach, i + nums\[i])
* Return True

**Python Code:**

```python
def canJump(nums):
    max_reach = 0
    for i, n in enumerate(nums):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i+n)
    return True
```

**T.C.:** O(n)
**S.C.:** O(1)
**Quick Recall Hack:** "Keep farthest reach → fail if you fall behind."

---

### 3️⃣ Jump Game II \[Must Do]

**Pattern / Idea:** Greedy → jump to farthest within current jump.

* Count jumps each time you exhaust current range.

**Pseudocode:**

* jumps = 0, current\_end = 0, farthest = 0
* For i in 0 to n-2:

  * farthest = max(farthest, i + nums\[i])
  * If i == current\_end:

    * jumps +=1
    * current\_end = farthest
* Return jumps

**Python Code:**

```python
def jump(nums):
    jumps = current_end = farthest = 0
    for i in range(len(nums)-1):
        farthest = max(farthest, i + nums[i])
        if i == current_end:
            jumps += 1
            current_end = farthest
    return jumps
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Jump only when range ends."

---

### 4️⃣ Gas Station \[Must Do]

**Pattern / Idea:** Greedy → if total gas ≥ total cost → solution exists. Track start index.

**Pseudocode:**

* total = curr = start = 0
* For i in range(n):

  * curr += gas\[i] - cost\[i]
  * total += gas\[i] - cost\[i]
  * If curr <0 → start = i+1, curr=0
* Return start if total ≥0 else -1

**Python Code:**

```python
def canCompleteCircuit(gas, cost):
    total = curr = start = 0
    for i in range(len(gas)):
        curr += gas[i] - cost[i]
        total += gas[i] - cost[i]
        if curr < 0:
            start = i+1
            curr = 0
    return start if total >= 0 else -1
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Reset start if tank goes negative."

---

### 5️⃣ Hand of Straights

**Pattern / Idea:** Use Counter + sort → always pick smallest first.

**Pseudocode:**

* Count frequencies → keys sorted
* For key in sorted keys:

  * while freq\[key] > 0:

    * For i in key to key+groupSize-1:

      * If freq\[i] < freq\[key] → return False
      * freq\[i] -= freq\[key]

**Python Code:**

```python
from collections import Counter
def isNStraightHand(hand, W):
    count = Counter(hand)
    for x in sorted(count):
        if count[x] > 0:
            for i in range(x, x+W):
                if count[i] < count[x]:
                    return False
                count[i] -= count[x]
    return True
```

**T.C.:** O(n log n)

**S.C.:** O(n)

**Quick Recall Hack:** "Always start from smallest → remove sequence."

---

### 6️⃣ Merge Triplets to Form Target Triplet

**Pattern / Idea:** Keep track of max values for each position ≤ target.

* Greedy → update achievable max.

**Python Code:**

```python
def mergeTriplets(triplets, target):
    a = b = c = 0
    for x, y, z in triplets:
        if x <= target[0] and y <= target[1] and z <= target[2]:
            a, b, c = max(a, x), max(b, y), max(c, z)
    return [a, b, c] == target
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Update max ≤ target → check final match."

---

### 7️⃣ Partition Labels

**Pattern / Idea:** Greedy → keep track of last occurrence → split partitions.

**Python Code:**

```python
def partitionLabels(s):
    last = {c:i for i,c in enumerate(s)}
    j = anchor = 0
    res = []
    for i, c in enumerate(s):
        j = max(j, last[c])
        if i == j:
            res.append(i - anchor + 1)
            anchor = i+1
    return res
```

**T.C.:** O(n)
**S.C.:** O(1)
**Quick Recall Hack:** "Partition when farthest index reached."

---

### 8️⃣ Valid Parenthesis String

**Pattern / Idea:** Greedy → track minOpen and maxOpen → for ‘\*’ treat as '(' or ')'.

**Python Code:**

```python
def checkValidString(s):
    minOpen = maxOpen = 0
    for c in s:
        if c == '(':
            minOpen += 1
            maxOpen += 1
        elif c == ')':
            minOpen = max(minOpen-1, 0)
            maxOpen -= 1
        else:  # '*'
            minOpen = max(minOpen-1, 0)
            maxOpen += 1
        if maxOpen < 0:
            return False
    return minOpen == 0
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** "Track min & max opens."

---



Got it. Let’s **crack Intervals problems** in a super-clear way, step by step, without confusing stuff like obscure lambdas. I’ll also explain why we do each step, so you actually **understand**, not just memorize.

We’ll start with the **core patterns**, then go problem by problem. I’ll mark **must-do non-FAANG problems**.

---

# Section 7: Intervals

---

### **Pattern / Idea for Intervals:**

1. **Sorting is almost always key** → either by start time or end time.
2. **Greedy merges or checks** → because intervals are continuous, you can make decisions locally.
3. **Lambda** is just a short way to sort with a key. Instead of worrying about it, think:

   * `sorted(intervals, key=lambda x: x[0])` → sort by start time
   * You can replace with a normal function or manual comparison if lambda confuses you.

**Cheat to memorize:** "Sort first → merge/compare → decide greedily."

---

### 1️⃣ Insert Interval \[Must Do]

**Problem:** Given a list of non-overlapping intervals sorted by start time, insert a new interval and merge if necessary.

**Pattern / Idea:**

* Append intervals that **end before** new interval → no overlap.
* Merge intervals that **overlap** with new interval.
* Append intervals that **start after** new interval → no overlap.

**Python Code (Simple, No Lambda Confusion):**

```python
def insert(intervals, newInterval):
    res = []
    i = 0
    n = len(intervals)
    
    # Add intervals before newInterval
    while i < n and intervals[i][1] < newInterval[0]:
        res.append(intervals[i])
        i += 1

    # Merge overlapping intervals
    while i < n and intervals[i][0] <= newInterval[1]:
        newInterval[0] = min(newInterval[0], intervals[i][0])
        newInterval[1] = max(newInterval[1], intervals[i][1])
        i += 1
    res.append(newInterval)

    # Add remaining intervals
    while i < n:
        res.append(intervals[i])
        i += 1

    return res
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** "Before → add, Overlap → merge, After → add."

---

### 2️⃣ Merge Intervals \[Must Do]

**Problem:** Merge all overlapping intervals.



---

### **Memory Hook for “Merge Intervals”**

1. **Sort by start** → always.

   * Think: “Leftmost interval first.”

2. **Keep a `merged` list** → start with first interval.

3. **Iterate over remaining intervals**:

   * Compare **start of current** with **end of last merged**:

     * **If overlap (start ≤ last end)** → merge: new end = max(current end, last end)
     * **Else** → append current to merged

4. **Done** → merged intervals contain no overlaps.

---

### **Visual Pattern (Mental Image)**

```
1---3
  2-----6
       8---10
               15---18
```



**Python Code (Simple, No Lambda Confusion):**

```python
def merge(intervals):
    if not intervals:
        return []
    # Step 1: Sort intervals by start
    intervals.sort(key=lambda x: x[0]) 
    merged = [intervals[0]]# Step 2: Start merged list with first interval
     # Step 3: Iterate through remaining intervals
    for curr in intervals[1:]:
        last = merged[-1]# last interval in merged
        if curr[0] <= last[1]:  # Overlap
            last[1] = max(last[1], curr[1]) # merge
        else:
            merged.append(curr)# no overlap, just add
    
    return merged
```

**T.C.:** O(n log n) (for sorting)

**S.C.:** O(n)

**Quick Recall Hack:** "Sort → compare with last → merge if overlap."

**Tip:** If lambda confuses you, think `sort(intervals, key=getStart)` where `getStart(interval)` returns interval\[0]. Same idea.

---

### 3️⃣ Non-Overlapping Intervals \[Must Do]

**Problem:** Given intervals, find minimum number of intervals to remove so that no overlaps remain.

**Pattern / Idea:**

* Sort by **end time** (important!)
* Keep track of `prev_end`.
* If current start < prev\_end → remove one.

**Python Code:**

```python
def eraseOverlapIntervals(intervals):
    if not intervals:
        return 0
    
    intervals.sort(key=lambda x: x[1])  # Sort by end time
    prev_end = intervals[0][1]
    remove = 0
    
    for i in range(1, len(intervals)):
        if intervals[i][0] < prev_end:
            remove += 1  # Overlap → remove current
        else:
            prev_end = intervals[i][1]
    
    return remove
```

**T.C.:** O(n log n)

**S.C.:** O(1)

**Quick Recall Hack:** "Sort by end → remove overlaps greedily."

---

### 4️⃣ Meeting Rooms

**Problem:** Given intervals, check if a person can attend all meetings.

**Pattern / Idea:**

* Sort by start.
* If any interval’s start < previous end → cannot attend all.

**Python Code:**

```python
def canAttendMeetings(intervals):
    intervals.sort(key=lambda x: x[0])
    for i in range(1, len(intervals)):
        if intervals[i][0] < intervals[i-1][1]:
            return False
    return True
```

**T.C.:** O(n log n)

**S.C.:** O(1)

**Quick Recall Hack:** "Sort by start → check consecutive overlap."

---

### 5️⃣ Meeting Rooms II \[Must Do]

**Problem:** Minimum number of meeting rooms needed.

**Pattern / Idea:**

* Use **two arrays**: start times and end times.
* Use two pointers → track how many meetings overlap → max is answer.

**Python Code (Simple, No Heap Needed):**

```python
def minMeetingRooms(intervals):
    if not intervals:
        return 0
    
    starts = sorted([i[0] for i in intervals])
    ends = sorted([i[1] for i in intervals])
    
    s = e = 0
    rooms = 0
    max_rooms = 0
    
    while s < len(intervals):
        if starts[s] < ends[e]:
            rooms += 1
            s += 1
        else:
            rooms -= 1
            e += 1
        max_rooms = max(max_rooms, rooms)
    
    return max_rooms
```

**T.C.:** O(n log n)

**S.C.:** O(n)

**Quick Recall Hack:** "Sort starts & ends → sweep → track overlap."

---

### 6️⃣ Minimum Interval to Include Each Query

**Pattern / Idea:**

* Sort intervals by start.
* For each query, check which intervals cover it → track minimum size.
* Use heap for efficiency if many queries.

*(This one is harder → usually you use heap. We can do a simple version later if you want.)*

---







# Section 8: Math & Geometry

---

### 1️⃣ Rotate Image \[Must Do]

**Problem:** Rotate an n × n matrix 90° clockwise **in-place**.

**Pattern / Idea:**

* Transpose the matrix → swap `matrix[i][j]` with `matrix[j][i]`
* Reverse each row

**Python Code:**

```python
def rotate(matrix):
    n = len(matrix)
    # Transpose
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # Reverse each row
    for row in matrix:
        row.reverse()
```

**T.C.:** O(n²)

**S.C.:** O(1)

**Quick Recall Hack:** "Transpose → reverse rows."

---

### 2️⃣ Spiral Matrix \[Must Do]

**Problem:** Return elements of a matrix in spiral order.

**Pattern / Idea:**

* Keep four boundaries: top, bottom, left, right
* Move right → down → left → up
* Shrink boundaries after each pass

**Python Code:**

```python
def spiralOrder(matrix):
    res = []
    if not matrix: return res
    top, bottom, left, right = 0, len(matrix)-1, 0, len(matrix[0])-1
    while top <= bottom and left <= right:
        for j in range(left, right+1):
            res.append(matrix[top][j])
        top += 1
        for i in range(top, bottom+1):
            res.append(matrix[i][right])
        right -= 1
        if top <= bottom:
            for j in range(right, left-1, -1):
                res.append(matrix[bottom][j])
            bottom -= 1
        if left <= right:
            for i in range(bottom, top-1, -1):
                res.append(matrix[i][left])
            left += 1
    return res
```

**T.C.:** O(m\*n)

**S.C.:** O(1) extra

**Quick Recall Hack:** "Keep shrinking boundaries → traverse in four directions."

---

### 3️⃣ Set Matrix Zeroes \[Must Do]

**Problem:** If an element is 0, set its entire row and column to 0 **in-place**.

**Pattern / Idea:**

* Use first row & first column as markers
* Track separately if first row/column has zero

**Python Code:**

```python
def setZeroes(matrix):
    rows, cols = len(matrix), len(matrix[0])
    first_row = any(matrix[0][j] == 0 for j in range(cols))
    first_col = any(matrix[i][0] == 0 for i in range(rows))
    
    # Mark zeros
    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][j] == 0:
                matrix[i][0] = matrix[0][j] = 0
    
    # Apply markers
    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0
    
    # First row/col
    if first_row:
        for j in range(cols):
            matrix[0][j] = 0
    if first_col:
        for i in range(rows):
            matrix[i][0] = 0
```

**T.C.:** O(m\*n)

**S.C.:** O(1) extra

**Quick Recall Hack:** "Use first row & col as flags."

---

### 4️⃣ Happy Number \[Must Do]

**Problem:** Determine if number eventually reaches 1 by replacing it with sum of squares of digits repeatedly.

**Pattern / Idea:**

* Detect cycle using **Floyd’s Tortoise and Hare**

**Python Code:**

```python
def isHappy(n):
    def get_next(x):
        return sum(int(d)**2 for d in str(x))
    
    slow = n
    fast = get_next(n)
    while fast != 1 and slow != fast:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    return fast == 1
```

**T.C.:** O(log n) (since numbers shrink)

**S.C.:** O(1)

**Quick Recall Hack:** "Detect cycle → sum of squares."

---

### 5️⃣ Plus One \[Must Do]

**Problem:** Increment an integer represented as an array of digits.

**Pattern / Idea:**

* Add 1 from last digit → handle carry

**Python Code:**

```python
def plusOne(digits):
    n = len(digits)
    for i in range(n-1, -1, -1):
        if digits[i] < 9:
            digits[i] += 1
            return digits
        digits[i] = 0
    return [1] + digits
```

**T.C.:** O(n)

**S.C.:** O(1) (or O(n) if new array)

**Quick Recall Hack:** "Add from end → propagate carry."

---

### 6️⃣ Pow(x, n) \[Must Do]

**Problem:** Compute xⁿ efficiently.

**Pattern / Idea:**

* Use **binary exponentiation**
* n even → square result, n odd → multiply

**Python Code:**

```python
def myPow(x, n):
    if n < 0:
        x = 1/x
        n = -n
    res = 1
    while n:
        if n % 2:
            res *= x
        x *= x
        n //= 2
    return res
```

**T.C.:** O(log n)

**S.C.:** O(1)

**Quick Recall Hack:** "Square & multiply → halve exponent."

---

### 7️⃣ Multiply Strings \[Must Do]

**Problem:** Multiply two numbers given as strings.

**Pattern / Idea:**

* Simulate multiplication like on paper → store in array

**Python Code:**

```python
def multiply(num1, num2):
    m, n = len(num1), len(num2)
    res = [0]*(m+n)
    
    for i in range(m-1, -1, -1):
        for j in range(n-1, -1, -1):
            mul = int(num1[i])*int(num2[j])
            sum_ = mul + res[i+j+1]
            res[i+j+1] = sum_ % 10
            res[i+j] += sum_ // 10
    
    # Convert to string, remove leading zeros
    result = ''.join(map(str, res)).lstrip('0')
    return result or '0'
```

**T.C.:** O(m\*n)

**S.C.:** O(m+n)

**Quick Recall Hack:** "Simulate school multiplication → store digits."

---

### 8️⃣ Detect Squares

**Problem:** Count number of squares formed from points (advanced geometry).

**Pattern / Idea:**

* Use combinations → check distances
* Only important if high-level; can skip memorizing tricks for interview unless needed


---

### 9️⃣ Detect Triangles \[Must Do]

**Problem:** Given an array of integers, count the number of triplets (i, j, k) such that `nums[i] + nums[j] > nums[k]` (triangle inequality).

**Pattern / Idea:**

* Sort array → because triangle inequality only needs `a + b > c` for sides in order.
* Use **two pointers** to efficiently count valid triplets.

**Pseudocode:**

1. Sort `nums`
2. For `k` from n-1 down to 2 (largest side):

   * left = 0, right = k-1
   * While left < right:

     * If nums\[left] + nums\[right] > nums\[k]:

       * count += right - left
       * right -= 1
     * Else:

       * left += 1

**Python Code:**

```python
def triangleNumber(nums):
    nums.sort()
    count = 0
    n = len(nums)
    for k in range(n-1, 1, -1):
        left, right = 0, k-1
        while left < right:
            if nums[left] + nums[right] > nums[k]:
                count += right - left
                right -= 1
            else:
                left += 1
    return count
```

**T.C.:** O(n²)

**S.C.:** O(1)

**Quick Recall Hack:** "Sort → fix largest → two pointers for left + right."

**Cheat to memorize:** "Largest side last → smaller two → count all valid."



# Section 9: Bit manipulation  **Bit Manipulation – Core Tricks**

---

### **1️⃣ Get the rightmost set bit**

**Trick:** `x & -x`

**What it does:**

* Gives a number with **only the rightmost 1 bit** of `x` set.

**Example:**

```text
x = 12 -> 1100 in binary
-x = -12 -> two’s complement = 0100 (last 1)
x & -x = 1100 & 0100 = 0100 = 4
```

**Use case:**

* Often used in **Single Number II** or **finding subsets**.

**Cheat to memorize:** “x & -x isolates last 1.”

---

### **2️⃣ Turn off the rightmost set bit**

**Trick:** `x & (x - 1)`

**What it does:**

* Removes the **lowest 1 bit** in x.

**Example:**

```text
x = 12 -> 1100
x - 1 = 11 -> 1011
x & (x-1) = 1100 & 1011 = 1000 = 8
```

**Use case:**

* Count number of 1’s in a number
* Detect powers of two (`x & (x-1) == 0`)

**Cheat to memorize:** “x & (x-1) kills last 1.”

---

### **3️⃣ Check if a number is power of 2**

**Trick:** `x > 0 and (x & (x - 1)) == 0`

**Why it works:**

* Powers of two have **exactly one 1-bit**.

**Example:**

```text
x = 8 -> 1000
x & (x-1) = 1000 & 0111 = 0 -> yes
x = 6 -> 0110
x & (x-1) = 0110 & 0101 = 0100 -> not 0
```

**Cheat:** “Power of two → only one 1-bit → x & (x-1) = 0.”

---

### **4️⃣ Count number of 1 bits (Brian Kernighan’s Algorithm)**

**Trick:** repeatedly use `x = x & (x-1)` until x becomes 0

**Example:**

```python
def countBits(x):
    count = 0
    while x:
        x &= x-1  # remove last set bit
        count += 1
    return count
```

**Example Run:**

* x = 12 → 1100
* 1st: 1100 & 1011 = 1000 → count=1
* 2nd: 1000 & 0111 = 0 → count=2

**Cheat:** “Each & (x-1) removes a 1 → count steps = number of 1’s.”

---

### **5️⃣ XOR tricks**

**Properties:**

1. `x ^ x = 0`
2. `x ^ 0 = x`
3. XOR is **commutative and associative**

**Use case:**

* Single Number problems
* Swapping numbers without temp variable

**Example – Single Number:**

```python
nums = [2,3,2]
res = 0
for num in nums:
    res ^= num
# res = 3
```

**Cheat:** “XOR cancels duplicates.”

---

### **6️⃣ Check if two numbers have opposite signs**

**Trick:** `(x ^ y) < 0`

**Why it works:**

* XOR of numbers with opposite signs → most significant bit = 1 → negative

**Example:**

```text
x = 5 (0101), y = -3 (two's complement 1101)
x ^ y = 1000 < 0 → True
```

---

### **7️⃣ Swap two numbers using XOR**

**Trick:**

```python
x = x ^ y
y = x ^ y
x = x ^ y
```

**Why it works:**

* Each step XORs out the original value.
* Avoids temporary variable.

---

### **8️⃣ Isolate last 0 bit**

**Trick:** `~x & (x + 1)`

**Example:**

```text
x = 10 -> 1010
x + 1 = 1011
~x = 0101
~x & (x+1) = 0101 & 1011 = 0001
```

**Use case:**

* Rare, mainly in advanced bitmask problems.

---

### **9️⃣ Count bits from 0…n (dynamic programming)**

**Trick:** `bits[i] = bits[i & (i-1)] + 1`

**Idea:**

* Use previously computed counts
* Efficient for “Counting Bits” problem

---

### **10️⃣ Subsets using bitmask**

**Pattern:**

* Treat 1s in binary as elements included
* Loop `i` from `0` to `2^n - 1`

**Example:**

```python
nums = [1,2,3]
for mask in range(1<<len(nums)):
    subset = [nums[j] for j in range(len(nums)) if mask & (1<<j)]
    print(subset)
```

**Cheat:** “Binary mask → subset yes/no for each bit.”



Perfect. Let’s convert your **Bit Manipulation** problems into the same **interview-ready format** with patterns, clear Python code, T.C./S.C., and quick cheat hacks. I’ll mark the **must-do ones** for non-FAANG interviews.

---

# **Bit Problems**

---

### 1️⃣ Single Number \[Must Do]

**Pattern / Idea:**

* Use **XOR** to cancel duplicates → `x ^ x = 0`

**Pseudocode:**

* res = 0
* For each num in nums → res ^= num
* Return res

**Python Code:**

```python
def singleNumber(nums):
    res = 0
    for num in nums:
        res ^= num
    return res
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “XOR cancels duplicates → left with single.”

---

### 2️⃣ Number of 1 Bits \[Must Do]

**Pattern / Idea:**

* Use **Brian Kernighan’s Algorithm** → repeatedly remove last set bit

**Python Code:**

```python
def hammingWeight(n):
    count = 0
    while n:
        n &= n-1
        count += 1
    return count
```

**T.C.:** O(number of 1s)

**S.C.:** O(1)

**Quick Recall Hack:** “Each & (n-1) kills last 1 → count = # of 1s.”

---

### 3️⃣ Counting Bits \[Must Do]

**Pattern / Idea:**

* Dynamic programming using **last set bit removal**:
  `bits[i] = bits[i & (i-1)] + 1`

**Python Code:**

```python
def countBits(n):
    bits = [0]*(n+1)
    for i in range(1, n+1):
        bits[i] = bits[i & (i-1)] + 1
    return bits
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** “Use previous smaller number by removing last 1.”

---

### 4️⃣ Reverse Bits \[Must Do]

**Pattern / Idea:**

* Shift bits → build reversed number

**Python Code:**

```python
def reverseBits(n):
    res = 0
    for _ in range(32):
        res = (res << 1) | (n & 1)
        n >>= 1
    return res
```

**T.C.:** O(32) → O(1)

**S.C.:** O(1)

**Quick Recall Hack:** “Shift left result + last bit from n.”

---

### 5️⃣ Missing Number \[Must Do]

**Pattern / Idea:**

* XOR all indices and all numbers → missing one remains

**Python Code:**

```python
def missingNumber(nums):
    n = len(nums)
    res = n
    for i, num in enumerate(nums):
        res ^= i ^ num
    return res
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “XOR indices & values → missing number left.”

---

### 6️⃣ Sum of Two Integers \[Must Do]

**Pattern / Idea:**

* Use **bitwise operations** to sum without `+`

**Python Code:**

```python
def getSum(a, b):
    mask = 0xFFFFFFFF
    while b != 0:
        a, b = (a ^ b) & mask, ((a & b) << 1) & mask
    # Handle negative numbers
    return a if a <= 0x7FFFFFFF else ~(a ^ mask)
```

**T.C.:** O(32) → O(1)

**S.C.:** O(1)

**Quick Recall Hack:** “XOR = sum, AND+shift = carry → repeat.”

---

### 7️⃣ Reverse Integer \[Must Do]

**Pattern / Idea:**

* Pop last digit → push to result
* Check overflow

**Python Code:**

```python
def reverse(x):
    res = 0
    sign = -1 if x < 0 else 1
    x = abs(x)
    while x:
        res = res*10 + x%10
        x //= 10
    res *= sign
    if res < -2**31 or res > 2**31-1:
        return 0
    return res
```

**T.C.:** O(log n)

**S.C.:** O(1)

**Quick Recall Hack:** “Pop & push digits → check 32-bit overflow.”


### ✅ Summary Cheats for Bit Manipulation:

1. **XOR cancels duplicates** → `x ^ x = 0`
2. **Remove last set bit** → `x & (x-1)`
3. **Isolate last 1 bit** → `x & -x`
4. **Check power of 2** → `(x & (x-1)) == 0`
5. **Count 1 bits** → repeatedly `x &= x-1`
6. **Subsets** → bitmask → `(mask & (1<<i))`
7. **Sum without +** → `a ^ b` (sum), `(a & b) << 1` (carry)

---




---

# **Section 10: Linked List**

---

### 1️⃣ Reverse Linked List \[Must Do]

**Pattern / Idea:**

* Iteratively reverse pointers → previous, current, next

**Python Code:**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None
    curr = head
    while curr:
        nxt = curr.next
        curr.next = prev
        prev = curr
        curr = nxt
    return prev
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “Prev → Curr → Next → reverse pointer.”

---

### 2️⃣ Merge Two Sorted Lists \[Must Do]

**Pattern / Idea:**

* Use dummy node → iterate both lists → pick smaller each step

**Python Code:**

```python
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    tail = dummy
    while l1 and l2:
        if l1.val < l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next
    tail.next = l1 or l2
    return dummy.next
```

**T.C.:** O(n + m)

**S.C.:** O(1)

**Quick Recall Hack:** “Dummy + tail → pick smaller → move pointers.”

---

### 3️⃣ Linked List Cycle \[Must Do]

**Pattern / Idea:**

* Use **Floyd’s Tortoise and Hare** → slow & fast pointers

**Python Code:**

```python
def hasCycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “Slow + Fast → meet = cycle.”

---

### 4️⃣ Reorder List \[Must Do]

**Problem:** L0 → L1 → … → Ln → reorder to L0 → Ln → L1 → Ln-1 …

**Pattern / Idea:**

* Find middle → reverse second half → merge two halves

**Python Code:**

```python
def reorderList(head):
    if not head or not head.next:
        return
    # Find middle
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    # Reverse second half
    prev, curr = None, slow.next
    slow.next = None
    while curr:
        nxt = curr.next
        curr.next = prev
        prev = curr
        curr = nxt
    # Merge halves
    first, second = head, prev
    while second:
        tmp1, tmp2 = first.next, second.next
        first.next, second.next = second, tmp1
        first, second = tmp1, tmp2
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “Middle → reverse → merge.”

---

### 5️⃣ Remove Nth Node From End \[Must Do]

**Pattern / Idea:**

* Two pointers → first advances n steps → move both until first is end → remove node

**Python Code:**

```python
def removeNthFromEnd(head, n):
    dummy = ListNode(0)
    dummy.next = head
    first = second = dummy
    for _ in range(n+1):
        first = first.next
    while first:
        first = first.next
        second = second.next
    second.next = second.next.next
    return dummy.next
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “Two pointers → remove nth from end.”

---

### 6️⃣ Copy List With Random Pointer \[Must Do]

**Pattern / Idea:**

* Use interleaving nodes → copy random pointers → separate lists

**Python Code:**

```python
class Node:
    def __init__(self, val, next=None, random=None):
        self.val = val
        self.next = next
        self.random = random

def copyRandomList(head):
    if not head:
        return None
    # Step 1: copy nodes interleaved
    curr = head
    while curr:
        nxt = curr.next
        curr.next = Node(curr.val)
        curr.next.next = nxt
        curr = nxt
    # Step 2: copy random
    curr = head
    while curr:
        if curr.random:
            curr.next.random = curr.random.next
        curr = curr.next.next
    # Step 3: separate lists
    curr, copy = head, head.next
    head_copy = copy
    while curr:
        curr.next = curr.next.next
        copy.next = copy.next.next if copy.next else None
        curr = curr.next
        copy = copy.next
    return head_copy
```

**T.C.:** O(n)

**S.C.:** O(1) extra (interleaving trick)

**Quick Recall Hack:** “Interleave → copy random → separate.”

---

### 7️⃣ Add Two Numbers \[Must Do]

**Pattern / Idea:**

* Iteratively add corresponding digits → carry → new node

**Python Code:**

```python
def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr, carry = dummy, 0
    while l1 or l2 or carry:
        val = carry
        if l1:
            val += l1.val
            l1 = l1.next
        if l2:
            val += l2.val
            l2 = l2.next
        carry, val = divmod(val, 10)
        curr.next = ListNode(val)
        curr = curr.next
    return dummy.next
```

**T.C.:** O(max(n, m))

**S.C.:** O(max(n, m))

**Quick Recall Hack:** “Digit-wise addition → carry → append.”

---

### 8️⃣ Find the Duplicate Number \[Must Do]

**Pattern / Idea:**

* **Linked List cycle detection trick** using indices → Floyd’s Tortoise & Hare,slow moves 1 step, fast moves 2 steps

**Python Code:**

```python
def findDuplicate(nums):
    slow = fast = nums[0]
    while True:#first detect the cycle,Treat the array as a linked list
        slow = nums[slow] #move 1 step
        fast = nums[nums[fast]] #move 2 steps
        if slow == fast:
            break
    #Phase 2:find entrance to the cycle,Reset slow to the start of the array.
    #The point where they meet again is the duplicate number, because that's the “entrance” of the cycle
    slow = nums[0]
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]
    return slow
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “Array values as pointers → detect cycle.”

---

### 9️⃣ LRU Cache \[Must Do]

**Pattern / Idea:**

* Use **OrderedDict or doubly linked list + hashmap** → O(1) get & put

**Python Code:**

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key):
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key, value):
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**T.C.:** O(1)

**S.C.:** O(capacity)

**Quick Recall Hack:** “OrderedDict → move\_to\_end → pop oldest.”

---

### 10️⃣ Merge K Sorted Lists \[Must Do]

**Pattern / Idea:**

* Use **heap (priority queue)** → always take smallest head

**Python Code:**

```python
from heapq import heappush, heappop

def mergeKLists(lists):
    heap = []
    for i, node in enumerate(lists):
        if node:
            heappush(heap, (node.val, i, node))
    dummy = curr = ListNode(0)
    while heap:
        val, i, node = heappop(heap)
        curr.next = node
        curr = curr.next
        if node.next:
            heappush(heap, (node.next.val, i, node.next))
    return dummy.next
```

**T.C.:** O(N log k) (N = total nodes, k = lists)

**S.C.:** O(k)

**Quick Recall Hack:** “Heap → always smallest head → append → push next.”

---

### 11️⃣ Reverse Nodes in k-Group \[Must Do]

**Pattern / Idea:**

* Reverse every k nodes → use dummy → iterative solution

**Python Code:**

```python
def reverseKGroup(head, k):
    dummy = jump = ListNode(0)
    dummy.next = head
    prev = head
    count = 0
    while head:
        count += 1
        if count % k == 0:
            prev = reverse(prev, jump.next, head.next)
            jump = prev
            head = prev.next
        else:
            head = head.next
    return dummy.next

def reverse(start, first, last):
    prev = last
    curr = first
    while curr != last:
        nxt = curr.next
        curr.next = prev
        prev = curr
        curr = nxt
    start.next = prev
    return first
```

**T.C.:** O(n)

**S.C.:** O(1)

**Quick Recall Hack:** “Reverse every k nodes → connect properly.”






---

# ** Section 11: Trees**

---

### 1️⃣ Invert Binary Tree \[Must Do]

**Pattern / Idea:**

* **Recursive swap** left and right children of every node

**Python Code:**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def invertTree(root):
    if not root:
        return None
    root.left, root.right = invertTree(root.right), invertTree(root.left)
    return root
```

**T.C.:** O(n)

**S.C.:** O(h) recursion stack, h = height

**Quick Recall Hack:** “Swap left & right recursively.”

---

### 2️⃣ Maximum Depth of Binary Tree \[Must Do]

**Pattern / Idea:**

* DFS recursion → max(left, right) + 1

**Python Code:**

```python
def maxDepth(root):
    if not root:
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “Depth = 1 + max of children.”

---

### 3️⃣ Diameter of Binary Tree \[Must Do]

**Pattern / Idea:**

* Diameter = max(left\_depth + right\_depth) at any node

**Python Code:**

```python
def diameterOfBinaryTree(root):
    res = 0
    def dfs(node):
        nonlocal res
        if not node:
            return 0
        left, right = dfs(node.left), dfs(node.right)
        res = max(res, left + right)
        return 1 + max(left, right)
    dfs(root)
    return res
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “Diameter = left\_depth + right\_depth max.”

---

### 4️⃣ Balanced Binary Tree \[Must Do]

**Pattern / Idea:**

* Check recursively → left/right height difference ≤ 1

**Python Code:**

```python
def isBalanced(root):
    def dfs(node):
        if not node:
            return 0, True
        lh, lb = dfs(node.left)
        rh, rb = dfs(node.right)
        height = 1 + max(lh, rh)
        balanced = lb and rb and abs(lh - rh) <= 1
        return height, balanced
    return dfs(root)[1]
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “Check height difference ≤ 1 recursively.”

---

### 5️⃣ Same Tree \[Must Do]

**Pattern / Idea:**

* DFS → compare values + recursively left and right

**Python Code:**

```python
def isSameTree(p, q):
    if not p and not q:
        return True
    if not p or not q or p.val != q.val:
        return False
    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “Values + structure must match recursively.”

---

### 6️⃣ Subtree of Another Tree \[Must Do]

**Pattern / Idea:**

* For each node in s → check if tree equals t

**Python Code:**

```python
def isSubtree(s, t):
    def isSame(a, b):
        if not a and not b:
            return True
        if not a or not b or a.val != b.val:
            return False
        return isSame(a.left, b.left) and isSame(a.right, b.right)
    
    if not s:
        return False
    return isSame(s, t) or isSubtree(s.left, t) or isSubtree(s.right, t)
```

**T.C.:** O(m\*n) worst-case

**S.C.:** O(h)

**Quick Recall Hack:** “Check every node for equality.”

---

### 7️⃣ Lowest Common Ancestor of BST \[Must Do]

**Pattern / Idea:**

* BST property → if root > both → go left, if root < both → go right, else root is LCA

**Python Code:**

```python
def lowestCommonAncestor(root, p, q):
    if root.val > p.val and root.val > q.val:
        return lowestCommonAncestor(root.left, p, q)
    elif root.val < p.val and root.val < q.val:
        return lowestCommonAncestor(root.right, p, q)
    else:
        return root
```

**T.C.:** O(h)

**S.C.:** O(h)

**Quick Recall Hack:** “BST → check sides → root in between → LCA.”

---

### 8️⃣ Binary Tree Level Order Traversal \[Must Do]

**Pattern / Idea:**

* BFS using queue → append each level

**Python Code:**

```python
from collections import deque
def levelOrder(root):
    if not root:
        return []
    res = []
    queue = deque([root])
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
        res.append(level)
    return res
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** “BFS → one level at a time.”

---

### 9️⃣ Binary Tree Right Side View \[Must Do]

**Pattern / Idea:**

* BFS → take last node in each level

**Python Code:**

```python
from collections import deque
def rightSideView(root):
    if not root:
        return []
    res = []
    queue = deque([root])
    while queue:
        for i in range(len(queue)):
            node = queue.popleft()
            if i == len(queue) - 1:
                res.append(node.val)
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
    return res
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** “BFS → pick last in level.”

---

### 10️⃣ Count Good Nodes in Binary Tree \[Medium]

**Pattern / Idea:**

* DFS → pass max value seen from root → node.val ≥ max → good

**Python Code:**

```python
def goodNodes(root):
    def dfs(node, max_val):
        if not node:
            return 0
        count = 1 if node.val >= max_val else 0
        max_val = max(max_val, node.val)
        count += dfs(node.left, max_val)
        count += dfs(node.right, max_val)
        return count
    return dfs(root, root.val)
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “Pass max from root → count node ≥ max.”

---

### 11️⃣ Validate Binary Search Tree \[Must Do]

**Pattern / Idea:**

* DFS → check min/max bounds for each node

**Python Code:**

```python
def isValidBST(root):
    def dfs(node, low, high):
        if not node:
            return True
        if not (low < node.val < high):
            return False
        return dfs(node.left, low, node.val) and dfs(node.right, node.val, high)
    return dfs(root, float('-inf'), float('inf'))
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “BST → all left < node < all right.”

---

### 12️⃣ Kth Smallest Element in BST \[Must Do]

**Pattern / Idea:**

* Inorder traversal → sorted order → return kth element

**Python Code:**

```python
def kthSmallest(root, k):
    stack = []
    while True:
        while root:
            stack.append(root)
            root = root.left
        root = stack.pop()
        k -= 1
        if k == 0:
            return root.val
        root = root.right
```

**T.C.:** O(h + k)

**S.C.:** O(h)

**Quick Recall Hack:** “Inorder → kth element.”

---

### 13️⃣ Construct Binary Tree from Preorder and Inorder \[Medium-Hard]

**Pattern / Idea:**

* Preorder → root
* Inorder → left/right subtrees

**Python Code:**

```python
def buildTree(preorder, inorder):
    if not preorder or not inorder:
        return None
    root_val = preorder[0]
    root = TreeNode(root_val)
    idx = inorder.index(root_val)
    root.left = buildTree(preorder[1:1+idx], inorder[:idx])
    root.right = buildTree(preorder[1+idx:], inorder[idx+1:])
    return root
```

**T.C.:** O(n²) (can optimize with hashmap to O(n))

**S.C.:** O(n)

**Quick Recall Hack:** “Preorder first → split inorder → recurse left/right.”

---

### 14️⃣ Binary Tree Maximum Path Sum \[Hard]

**Pattern / Idea:**

* Recursive DFS → max path through node = left + right + node.val
* Track global max

**Python Code:**

```python
def maxPathSum(root):
    res = float('-inf')
    def dfs(node):
        nonlocal res
        if not node: return 0
        left = max(dfs(node.left), 0)
        right = max(dfs(node.right), 0)
        res = max(res, node.val + left + right)
        return node.val + max(left, right)
    dfs(root)
    return res
```

**T.C.:** O(n)

**S.C.:** O(h)

**Quick Recall Hack:** “Return max single path, track max through node.”

---

### 15️⃣ Serialize and Deserialize Binary Tree \[Medium-Hard]

**Pattern / Idea:**

* Preorder traversal → store `None` as marker
* Reconstruct recursively

**Python Code:**

```python
def serialize(root):
    res = []
    def dfs(node):
        if not node:
            res.append('X')
            return
        res.append(str(node.val))
        dfs(node.left)
        dfs(node.right)
    dfs(root)
    return ','.join(res)

def deserialize(data):
    vals = iter(data.split(','))
    def dfs():
        val = next(vals)
        if val == 'X':
            return None
        node = TreeNode(int(val))
        node.left = dfs()
        node.right = dfs()
        return node
    return dfs()
```

**T.C.:** O(n)

**S.C.:** O(n)

**Quick Recall Hack:** “Preorder with null → reconstruct recursively.”






Perfect. Let’s move on to **Heap / Priority Queue** problems. These are **medium to hard in interviews**, but once you understand **min/max heap tricks**, they become very systematic. I’ll include **patterns, clear Python code, T.C./S.C., and quick interview cheats**.

---

# ** Section 12 : Heap / Priority Queue**

---

### 1️⃣ Kth Largest Element in a Stream \[Must Do]

**Pattern / Idea:**

* Maintain a **min-heap of size k** → top of heap is kth largest

**Python Code:**

```python
import heapq

class KthLargest:
    def __init__(self, k, nums):
        self.k = k
        self.heap = nums
        heapq.heapify(self.heap)
        while len(self.heap) > k:
            heapq.heappop(self.heap)

    def add(self, val):
        heapq.heappush(self.heap, val)
        if len(self.heap) > self.k:
            heapq.heappop(self.heap)
        return self.heap[0]
```

**T.C.:** O(log k) per add

**S.C.:** O(k)

**Quick Recall Hack:** “Min-heap size k → top = kth largest.”

---

### 2️⃣ Last Stone Weight \[Medium]

**Pattern / Idea:**

* Use **max-heap** → smash two largest stones each time

**Python Code:**

```python
import heapq

def lastStoneWeight(stones):
    stones = [-s for s in stones]  # max-heap
    heapq.heapify(stones)
    while len(stones) > 1:
        first = -heapq.heappop(stones)
        second = -heapq.heappop(stones)
        if first != second:
            heapq.heappush(stones, -(first - second))
    return -stones[0] if stones else 0
```

**T.C.:** O(n log n)

**S.C.:** O(n)

**Quick Recall Hack:** “Max-heap → smash top 2 → push remainder.”

---

### 3️⃣ K Closest Points to Origin \[Must Do]

**Pattern / Idea:**

* Use **max-heap of size k** based on distance² → keep closest k

**Python Code:**

```python
import heapq

def kClosest(points, k):
    heap = []
    for x, y in points:
        dist = -(x*x + y*y)
        if len(heap) < k:
            heapq.heappush(heap, (dist, x, y))
        else:
            heapq.heappushpop(heap, (dist, x, y))
    return [(x, y) for (_, x, y) in heap]
```

**T.C.:** O(n log k)

**S.C.:** O(k)

**Quick Recall Hack:** “Max-heap of size k → keep closest.”

---

### 4️⃣ Kth Largest Element in an Array \[Must Do]

**Pattern / Idea:**

* Same as Kth largest in stream → min-heap size k

**Python Code:**

```python
import heapq

def findKthLargest(nums, k):
    heap = nums[:k]
    heapq.heapify(heap)
    for num in nums[k:]:
        if num > heap[0]:
            heapq.heappushpop(heap, num)
    return heap[0]
```

**T.C.:** O(n log k)

**S.C.:** O(k)

**Quick Recall Hack:** “Min-heap size k → top = kth largest.”

---

### 5️⃣ Task Scheduler \[Medium-Hard]

**Pattern / Idea:**

* Use **max-heap for frequencies** + greedy scheduling

**Python Code:**

```python
from collections import Counter
import heapq

def leastInterval(tasks, n):
    freq = Counter(tasks)
    heap = [-cnt for cnt in freq.values()]
    heapq.heapify(heap)
    time = 0
    while heap:
        temp = []
        for _ in range(n + 1):
            if heap:
                temp.append(heapq.heappop(heap))
        for item in temp:
            if item + 1 < 0:
                heapq.heappush(heap, item + 1)
        time += n + 1 if heap else len(temp)
    return time
```

**T.C.:** O(t log 26) → t = number of tasks

**S.C.:** O(26)

**Quick Recall Hack:** “Max frequency first → schedule n+1 window.”

---

### 6️⃣ Design Twitter \[Hard]

**Pattern / Idea:**

* Use **heap** to merge recent posts from multiple users → get top 10

**Python Code (simplified feed):**

```python
import heapq
from collections import defaultdict

class Twitter:
    def __init__(self):
        self.time = 0
        self.tweets = defaultdict(list)
        self.followees = defaultdict(set)

    def postTweet(self, userId, tweetId):
        self.tweets[userId].append((self.time, tweetId))
        self.time -= 1  # decreasing to simulate max-heap by time

    def getNewsFeed(self, userId):
        heap = []
        self.followees[userId].add(userId)
        for uid in self.followees[userId]:
            for tweet in self.tweets[uid][-10:]:
                heapq.heappush(heap, tweet)
        return [tweetId for _, tweetId in heapq.nlargest(10, heap)]

    def follow(self, followerId, followeeId):
        self.followees[followerId].add(followeeId)

    def unfollow(self, followerId, followeeId):
        self.followees[followerId].discard(followeeId)
```

**T.C.:** O(n log 10) for feed

**S.C.:** O(n)

**Quick Recall Hack:** “Heap → merge recent posts → pick top 10.”

---

### 7️⃣ Find Median from Data Stream \[Hard]

**Pattern / Idea:**

* **Two heaps** → max-heap left, min-heap right → balance sizes

**Python Code:**

```python
import heapq

class MedianFinder:
    def __init__(self):
        self.low = []  # max-heap
        self.high = [] # min-heap

    def addNum(self, num):
        heapq.heappush(self.low, -num)
        heapq.heappush(self.high, -heapq.heappop(self.low))
        if len(self.low) < len(self.high):
            heapq.heappush(self.low, -heapq.heappop(self.high))

    def findMedian(self):
        if len(self.low) > len(self.high):
            return -self.low[0]
        return (-self.low[0] + self.high[0]) / 2
```

**T.C.:** O(log n) per add, O(1) median

**S.C.:** O(n)

**Quick Recall Hack:** “Two heaps → max left, min right → balance → median.”

---

### ✅ **Heap / Priority Queue Summary Cheats**

1. **Min-heap for kth largest** → keep heap size k
2. **Max-heap for largest elements or frequencies** → use `-val`
3. **Merge k sorted / recent posts** → heap to pick smallest/largest top efficiently
4. **Median → two heaps** → max-left, min-right → balance

---





---

# 📌 Graphs (Must Do Set)
# ** Section 13 :Graphs **
---

### 1️⃣ Number of Islands \[Must Do]

**Pattern / Idea:** DFS/BFS flood fill – turn connected `1`s into water.
**Steps:**

1. Iterate grid cells
2. If land → run DFS/BFS → sink island (mark visited or flip to `0`)
3. Count +1 per DFS start

**Python Code:**

```python
def numIslands(grid):
    if not grid: return 0
    rows, cols = len(grid), len(grid[0])
    visited = set()
    
    def dfs(r, c):
        if (r < 0 or c < 0 or r >= rows or c >= cols or
            grid[r][c] == "0" or (r, c) in visited):
            return
        visited.add((r, c))
        dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1)
    
    islands = 0
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == "1" and (r, c) not in visited:
                dfs(r, c)
                islands += 1
    return islands
```

**T.C.:** O(m·n)

**S.C.:** O(m·n) recursion/visited

**Quick Recall Hack:** “Each DFS = 1 island.”

---

### 2️⃣ Max Area of Island \[Must Do]

**Pattern / Idea:** Same DFS flood fill, but count size.
**Steps:**

1. Traverse grid
2. Run DFS when land found, return area size
3. Track max size

**Python Code:**

```python
def maxAreaOfIsland(grid):
    rows, cols = len(grid), len(grid[0])
    visited = set()
    
    def dfs(r, c):
        if (r < 0 or c < 0 or r >= rows or c >= cols or
            grid[r][c] == 0 or (r, c) in visited):
            return 0
        visited.add((r, c))
        return (1 + dfs(r+1, c) + dfs(r-1, c) +
                   dfs(r, c+1) + dfs(r, c-1))
    
    max_area = 0
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 1 and (r, c) not in visited:
                max_area = max(max_area, dfs(r, c))
    return max_area
```

**T.C.:** O(m·n)

**S.C.:** O(m·n)

**Quick Recall Hack:** “DFS + count size.”

---

### 3️⃣ Clone Graph \[Must Do]

**Pattern / Idea:** Graph traversal + hashmap to clone nodes.
**Steps:**

1. Use DFS/BFS
2. Map original node → new node
3. Traverse neighbors, build connections

**Python Code:**

```python
class Node:
    def __init__(self, val=0, neighbors=None):
        self.val = val
        self.neighbors = neighbors if neighbors else []

def cloneGraph(node):
    oldToNew = {}
    def dfs(n):
        if n in oldToNew:
            return oldToNew[n]
        copy = Node(n.val)
        oldToNew[n] = copy
        for nei in n.neighbors:
            copy.neighbors.append(dfs(nei))
        return copy
    return dfs(node) if node else None
```

**T.C.:** O(V+E)

**S.C.:** O(V)

**Quick Recall Hack:** “Map old→new, DFS clone neighbors.”

---

### 4️⃣ Walls and Gates \[Must Do]

**Pattern / Idea:** Multi-source BFS from all gates (`0`).
**Steps:**

1. Add all gate positions to queue
2. BFS, spreading distance outward
3. Update rooms as min distance

**Python Code:**

```python
from collections import deque

def wallsAndGates(rooms):
    rows, cols = len(rooms), len(rooms[0])
    q = deque()
    INF = 2147483647
    
    for r in range(rows):
        for c in range(cols):
            if rooms[r][c] == 0:
                q.append((r, c))
    
    directions = [(1,0),(-1,0),(0,1),(0,-1)]
    while q:
        r, c = q.popleft()
        for dr, dc in directions:
            nr, nc = r+dr, c+dc
            if 0 <= nr < rows and 0 <= nc < cols and rooms[nr][nc] == INF:
                rooms[nr][nc] = rooms[r][c] + 1
                q.append((nr, nc))
```

**T.C.:** O(m·n)

**S.C.:** O(m·n)

**Quick Recall Hack:** “Push all gates → BFS expand.”

---

### 5️⃣ Rotting Oranges \[Must Do]

**Pattern / Idea:** BFS from all rotten oranges at once.
**Steps:**

1. Add all rotten (2) to queue with time=0
2. BFS spread → infect fresh (1)
3. Track max minutes, check if fresh left

**Python Code:**

```python
from collections import deque

def orangesRotting(grid):
    rows, cols = len(grid), len(grid[0])
    q = deque()
    fresh = 0
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                q.append((r, c, 0))
            elif grid[r][c] == 1:
                fresh += 1
    
    directions = [(1,0),(-1,0),(0,1),(0,-1)]
    minutes = 0
    while q:
        r, c, t = q.popleft()
        for dr, dc in directions:
            nr, nc = r+dr, c+dc
            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:
                grid[nr][nc] = 2
                fresh -= 1
                q.append((nr, nc, t+1))
                minutes = t+1
    return minutes if fresh == 0 else -1
```

**T.C.:** O(m·n)

**S.C.:** O(m·n)

**Quick Recall Hack:** “Multi-BFS from rotten → last minute.”

---

### 6️⃣ Pacific Atlantic Water Flow \[Must Do]

**Pattern / Idea:** Reverse thinking – BFS/DFS from oceans, not from every cell.
**Steps:**

1. Run DFS from Pacific edge → mark reachable
2. Run DFS from Atlantic edge → mark reachable
3. Answer = intersection of both

**Python Code:**

```python
def pacificAtlantic(heights):
    rows, cols = len(heights), len(heights[0])
    pac, atl = set(), set()
    
    def dfs(r, c, visited, prevHeight):
        if (r < 0 or c < 0 or r >= rows or c >= cols or
            (r, c) in visited or heights[r][c] < prevHeight):
            return
        visited.add((r, c))
        dfs(r+1, c, visited, heights[r][c])
        dfs(r-1, c, visited, heights[r][c])
        dfs(r, c+1, visited, heights[r][c])
        dfs(r, c-1, visited, heights[r][c])
    
    for c in range(cols):
        dfs(0, c, pac, heights[0][c])
        dfs(rows-1, c, atl, heights[rows-1][c])
    for r in range(rows):
        dfs(r, 0, pac, heights[r][0])
        dfs(r, cols-1, atl, heights[r][cols-1])
    
    return list(pac & atl)
```

**T.C.:** O(m·n)

**S.C.:** O(m·n)

**Quick Recall Hack:** “Flow backwards → mark Pacific & Atlantic → intersect.”

---


---

# 📌 Graphs (Part 2)

---

### 7️⃣ Surrounded Regions \[Must Do]

**Pattern / Idea:** “Boundary DFS” — if an `O` is connected to boundary, it’s safe.
**Steps:**

1. Run DFS/BFS from boundary `O`s → mark as safe
2. Traverse board → flip unmarked `O` → `X`
3. Restore safe marks → `O`

**Code:**

```python
def solve(board):
    rows, cols = len(board), len(board[0])

    def dfs(r, c):
        if r < 0 or c < 0 or r >= rows or c >= cols or board[r][c] != "O":
            return
        board[r][c] = "S"
        dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1)

    for r in range(rows):
        dfs(r, 0); dfs(r, cols-1)
    for c in range(cols):
        dfs(0, c); dfs(rows-1, c)

    for r in range(rows):
        for c in range(cols):
            if board[r][c] == "O": board[r][c] = "X"
            elif board[r][c] == "S": board[r][c] = "O"
```

**T.C.:** O(m·n)

**S.C.:** O(m·n) recursion

**Hack:** “Flood from borders, rest flip.”

---

### 8️⃣ Course Schedule (Topological Sort) \[Must Do]

**Pattern / Idea:** Directed graph cycle detection.
**Steps:**

1. Build adj list of prereqs
2. DFS with 3 states: unvisited, visiting, visited
3. If cycle → False else True

**Code:**

```python
def canFinish(numCourses, prerequisites):
    adj = {i: [] for i in range(numCourses)}
    for a, b in prerequisites:
        adj[a].append(b)

    visited = [0]*numCourses  # 0=unvisited,1=visiting,2=done
    
    def dfs(course):
        if visited[course] == 1: return False
        if visited[course] == 2: return True
        visited[course] = 1
        for nei in adj[course]:
            if not dfs(nei): return False
        visited[course] = 2
        return True
    
    for c in range(numCourses):
        if not dfs(c): return False
    return True
```

**T.C.:** O(V+E)

**S.C.:** O(V+E)

**Hack:** “DFS cycle check = can finish.”

---

### 9️⃣ Course Schedule II \[Must Do]

**Pattern / Idea:** Topological ordering.
**Steps:**

1. Build adj + indegree
2. BFS queue with indegree=0
3. Pop → reduce indegree → push new zero indegree
4. If all visited → return order

**Code:**

```python
from collections import deque

def findOrder(numCourses, prerequisites):
    adj = {i: [] for i in range(numCourses)}
    indeg = [0]*numCourses
    for a,b in prerequisites:
        adj[b].append(a)
        indeg[a]+=1
    
    q = deque([i for i in range(numCourses) if indeg[i]==0])
    res=[]
    while q:
        c=q.popleft()
        res.append(c)
        for nei in adj[c]:
            indeg[nei]-=1
            if indeg[nei]==0:
                q.append(nei)
    return res if len(res)==numCourses else []
```

**T.C.:** O(V+E)
**S.C.:** O(V+E)
**Hack:** “Indegree BFS = order.”

---

### 🔟 Graph Valid Tree \[Must Do]

**Pattern / Idea:** Tree if (1) connected and (2) edges = nodes-1.
**Steps:**

1. Check edge count = n-1
2. DFS/BFS check connectivity
3. If connected → True

**Code:**

```python
def validTree(n, edges):
    if len(edges)!=n-1: return False
    adj={i:[] for i in range(n)}
    for a,b in edges:
        adj[a].append(b)
        adj[b].append(a)
    visited=set()
    
    def dfs(node, prev):
        if node in visited: return
        visited.add(node)
        for nei in adj[node]:
            if nei!=prev: dfs(nei, node)
    
    dfs(0,-1)
    return len(visited)==n
```

**T.C.:** O(V+E)

**S.C.:** O(V)

**Hack:** “Edges=n-1 + connected = tree.”

---

### 1️⃣1️⃣ Number of Connected Components \[Must Do]

**Pattern / Idea:** Count DFS starts in undirected graph.
**Steps:**

1. Build adj
2. DFS each unvisited node
3. Count connected comps

**Code:**

```python
def countComponents(n, edges):
    adj={i:[] for i in range(n)}
    for a,b in edges:
        adj[a].append(b)
        adj[b].append(a)
    visited=set()
    def dfs(node):
        if node in visited: return
        visited.add(node)
        for nei in adj[node]: dfs(nei)
    comps=0
    for i in range(n):
        if i not in visited:
            dfs(i)
            comps+=1
    return comps
```

**T.C.:** O(V+E)
**S.C.:** O(V+E)
**Hack:** “DFS count starts = comps.”

---

### 1️⃣2️⃣ Redundant Connection \[Must Do]

**Pattern / Idea:** Union-Find (detect first edge making cycle).
**Steps:**

1. DSU with find+union
2. For each edge, if already connected → return edge

**Code:**

```python
def findRedundantConnection(edges):
    parent=[i for i in range(len(edges)+1)]
    rank=[1]*(len(edges)+1)
    
    def find(x):
        while x!=parent[x]:
            parent[x]=parent[parent[x]]
            x=parent[x]
        return x
    
    def union(x,y):
        p1,p2=find(x),find(y)
        if p1==p2: return False
        if rank[p1]>rank[p2]:
            parent[p2]=p1
            rank[p1]+=rank[p2]
        else:
            parent[p1]=p2
            rank[p2]+=rank[p1]
        return True
    
    for u,v in edges:
        if not union(u,v): return [u,v]
```

**T.C.:** O(E·α(V))

**S.C.:** O(V)

**Hack:** “Union-Find, first cycle edge.”

---

### 1️⃣3️⃣ Word Ladder \[Must Do]

**Pattern / Idea:** BFS shortest path in word graph.
**Steps:**

1. Preprocess words by wildcard patterns (`h*t`, `*it`)
2. BFS from `beginWord`
3. Stop when reaching `endWord`

**Code:**

```python
from collections import deque, defaultdict

def ladderLength(beginWord, endWord, wordList):
    if endWord not in wordList: return 0
    wordList=set(wordList)
    adj=defaultdict(list)
    for word in wordList:
        for i in range(len(word)):
            pattern=word[:i]+"*"+word[i+1:]
            adj[pattern].append(word)
    
    q=deque([(beginWord,1)])
    visited=set([beginWord])
    while q:
        word,level=q.popleft()
        if word==endWord: return level
        for i in range(len(word)):
            pattern=word[:i]+"*"+word[i+1:]
            for nei in adj.get(pattern,[]):
                if nei not in visited:
                    visited.add(nei)
                    q.append((nei,level+1))
    return 0
```

**T.C.:** O(N·L²) (N=words, L=word length)

**S.C.:** O(N·L)

**Hack:** “Wildcard dict + BFS shortest path.”

---





---

# ** 📌Section 14 : 1-D Dynamic Programming  ** 

---

### 1️⃣ Climbing Stairs \[Must Do]

**Pattern / Idea:** Classic Fibonacci-like DP. Number of ways to reach step `n` = ways to reach `n-1` + ways to reach `n-2`.

**Steps:**

1. Base: step 0 → 1 way, step 1 → 1 way
2. DP\[i] = DP\[i-1] + DP\[i-2]
3. Return DP\[n]

**Python Code:**

```python
def climbStairs(n):
    if n <= 2: return n
    a, b = 1, 2
    for _ in range(3, n+1):
        a, b = b, a + b
    return b
```

**T.C.:** O(n)

**S.C.:** O(1)

**Hack:** “Fib sequence → step counts.”

---

### 2️⃣ Min Cost Climbing Stairs \[Must Do]

**Pattern / Idea:** DP min cost to reach top. Either take step from i-1 or i-2.

**Steps:**

1. DP\[i] = cost\[i] + min(DP\[i-1], DP\[i-2])
2. Return min(DP\[n-1], DP\[n-2])

**Code:**

```python
def minCostClimbingStairs(cost):
    a, b = cost[0], cost[1]
    for i in range(2, len(cost)):
        a, b = b, cost[i] + min(a, b)
    return min(a, b)
```

**T.C.:** O(n)

**S.C.:** O(1)

**Hack:** “Keep rolling min of last two steps.”

---

### 3️⃣ House Robber \[Must Do]

**Pattern / Idea:** DP: max money at house i = max(rob i or skip i).

**Steps:**

1. DP\[i] = max(DP\[i-1], DP\[i-2]+nums\[i])
2. Use rolling variables

**Code:**

```python
def rob(nums):
    prev, curr = 0, 0
    for n in nums:
        prev, curr = curr, max(curr, prev+n)
    return curr
```

**T.C.:** O(n)

**S.C.:** O(1)

**Hack:** “Prev two max → rob or skip.”

---

### 4️⃣ House Robber II

**Pattern / Idea:** Circular variant. Solve twice (exclude first or last).

**Steps:**

1. rob\_linear(nums\[:-1])
2. rob\_linear(nums\[1:])
3. Return max

**Code:**

```python
def rob_linear(nums):
    prev, curr = 0, 0
    for n in nums:
        prev, curr = curr, max(curr, prev+n)
    return curr

def rob2(nums):
    if len(nums)==1: return nums[0]
    return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))
```

**T.C.:** O(n)

**S.C.:** O(1)

**Hack:** “Break circle → two runs.”

---

### 5️⃣ Longest Palindromic Substring \[Must Do]

**Pattern / Idea:** Expand around center.

**Steps:**

1. Iterate each index as center
2. Expand for odd/even palindromes
3. Track max length

**Code:**

```python
def longestPalindrome(s):
    def expand(l,r):
        while l>=0 and r<len(s) and s[l]==s[r]:
            l-=1; r+=1
        return s[l+1:r]
    
    res=""
    for i in range(len(s)):
        res=max(res, expand(i,i), expand(i,i+1), key=len)
    return res
```

**T.C.:** O(n²)

**S.C.:** O(1)

**Hack:** “Center expand → longest.”

---

### 6️⃣ Palindromic Substrings

**Pattern / Idea:** Count all palindromes via center expand

**Steps:**

1. Each index: expand odd/even
2. Count all valid expansions

**Code:**

```python
def countSubstrings(s):
    def expand(l,r):
        count=0
        while l>=0 and r<len(s) and s[l]==s[r]:
            count+=1
            l-=1; r+=1
        return count
    
    total=0
    for i in range(len(s)):
        total+=expand(i,i)
        total+=expand(i,i+1)
    return total
```

**T.C.:** O(n²)

**S.C.:** O(1)

**Hack:** “Expand from each center → count.”

---

### 7️⃣ Decode Ways \[Must Do]

**Pattern / Idea:** DP: ways\[i] = ways\[i-1] (single) + ways\[i-2] (pair valid)

**Steps:**

1. DP\[0]=1 (empty string)
2. For each i: add single + double if valid
3. Return DP\[n]

**Code:**

```python
def numDecodings(s):
    if not s or s[0]=='0': return 0
    n=len(s)
    dp=[0]*(n+1)
    dp[0]=1; dp[1]=1
    for i in range(2,n+1):
        if s[i-1]!='0': dp[i]+=dp[i-1]
        if 10<=int(s[i-2:i])<=26: dp[i]+=dp[i-2]
    return dp[n]
```

**T.C.:** O(n)

**S.C.:** O(n)

**Hack:** “Single + pair valid → sum ways.”

---

### 8️⃣ Coin Change \[Must Do]

**Pattern / Idea:** DP min coins for amount.

**Steps:**

1. DP\[0]=0
2. DP\[i]=min(DP\[i], DP\[i-coin]+1) for all coins
3. Return DP\[amount] if reachable else -1

**Code:**

```python
def coinChange(coins, amount):
    dp=[float('inf')]*(amount+1)
    dp[0]=0
    for i in range(1, amount+1):
        for c in coins:
            if i>=c:
                dp[i]=min(dp[i], dp[i-c]+1)
    return dp[amount] if dp[amount]!=float('inf') else -1
```


**T.C.:** O(amount·coins)

**S.C.:** O(amount)

**Hack:** “Build min coins up → DP array.”

---

### 9️⃣ Maximum Product Subarray

**Pattern / Idea:** Track max/min product due to negatives.

**Steps:**

1. Maintain `curr_max` & `curr_min`
2. Swap if negative
3. Update global max

**Code:**

```python
def maxProduct(nums):
    res = curr_max = curr_min = nums[0]
    for n in nums[1:]:
        if n<0: curr_max, curr_min = curr_min, curr_max
        curr_max = max(n, curr_max*n)
        curr_min = min(n, curr_min*n)
        res = max(res, curr_max)
    return res
```

**T.C.:** O(n)

**S.C.:** O(1)

**Hack:** “Negatives swap max/min → track global max.”

---

### 1️⃣0️⃣ Word Break \[Must Do]

**Pattern / Idea:** DP: can s\[:i] be segmented?

**Steps:**

1. DP\[0]=True
2. For i in 1..n, check j\<i: dp\[j] and s\[j\:i] in wordDict
3. Return dp\[n]

**Code:**

```python
def wordBreak(s, wordDict):
    wordSet=set(wordDict)
    dp=[False]*(len(s)+1)
    dp[0]=True
    for i in range(1,len(s)+1):
        for j in range(i):
            if dp[j] and s[j:i] in wordSet:
                dp[i]=True
                break
    return dp[len(s)]
```

**T.C.:** O(n²·w) (w=max word length)
**S.C.:** O(n)
**Hack:** “DP prefix + word set lookup.”

---

### 1️⃣1️⃣ Longest Increasing Subsequence \[Must Do]

**Pattern / Idea:** DP\[i]=max LIS ending at i.

**Steps:**

1. DP\[i]=max(1 + DP\[j] for j\<i if nums\[j]\<nums\[i])
2. Return max(DP)

**Code:**

```python
def lengthOfLIS(nums):
    dp=[1]*len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[j]<nums[i]:
                dp[i]=max(dp[i], dp[j]+1)
    return max(dp)
```

**T.C.:** O(n²)

**S.C.:** O(n)

**Hack:** “Track LIS ending at each index.”

---

### 1️⃣2️⃣ Partition Equal Subset Sum \[Must Do]

**Pattern / Idea:** 0/1 Knapsack subset sum problem.

**Steps:**

1. Total sum must be even
2. DP\[i]=True if sum i achievable
3. Return DP\[total//2]

**Code:**

```python
def canPartition(nums):
    total=sum(nums)
    if total%2!=0: return False
    target=total//2
    dp=[False]*(target+1)
    dp[0]=True
    for num in nums:
        for i in range(target,num-1,-1):
            dp[i]=dp[i] or dp[i-num]
    return dp[target]
```

**T.C.:** O(n\*sum)

**S.C.:** O(sum)

**Hack:** “0/1 knapsack → target = sum/2.”

---





---

# 📌**  Section 15: 2-D Dynamic Programming (Must Do) **

---

### 1️⃣ Unique Paths \[Must Do]

**Pattern / Idea:** DP grid: ways to reach cell = from top + from left

**Steps:**

1. Initialize DP\[0]\[*] = 1, DP\[*]\[0] = 1
2. For each cell: DP\[i]\[j] = DP\[i-1]\[j] + DP\[i]\[j-1]
3. Return DP\[m-1]\[n-1]

**Code:**

```python
def uniquePaths(m, n):
    dp = [[1]*n for _ in range(m)]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[m-1][n-1]
```

**T.C.:** O(m·n)
**S.C.:** O(m·n)
**Hack:** “Ways = top + left.”

---

### 2️⃣ Longest Common Subsequence \[Must Do]

**Pattern / Idea:** DP\[i]\[j] = LCS of s1\[:i], s2\[:j]

**Steps:**

1. If chars match → DP\[i]\[j] = 1 + DP\[i-1]\[j-1]
2. Else → DP\[i]\[j] = max(DP\[i-1]\[j], DP\[i]\[j-1])
3. Return DP\[m]\[n]

**Code:**

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0]*(n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if text1[i-1]==text2[j-1]:
                dp[i][j]=1+dp[i-1][j-1]
            else:
                dp[i][j]=max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]
```

**T.C.:** O(m·n)
**S.C.:** O(m·n)
**Hack:** “Match → diagonal+1, else max(left, top).”

---

### 3️⃣ Best Time to Buy and Sell Stock with Cooldown \[Must Do]

**Pattern / Idea:** Track DP: hold, sold, rest

**Steps:**

1. hold\[i] = max(hold\[i-1], rest\[i-1]-price)
2. sold\[i] = hold\[i-1]+price
3. rest\[i] = max(rest\[i-1], sold\[i-1])
4. Return max(sold\[-1], rest\[-1])

**Code:**

```python
def maxProfit(prices):
    if not prices: return 0
    n = len(prices)
    hold, sold, rest = -prices[0], 0, 0
    for i in range(1, n):
        prev_hold, prev_sold, prev_rest = hold, sold, rest
        hold = max(prev_hold, prev_rest-prices[i])
        sold = prev_hold + prices[i]
        rest = max(prev_rest, prev_sold)
    return max(sold, rest)
```

**T.C.:** O(n)
**S.C.:** O(1)
**Hack:** “3 states → hold/sell/rest.”

---

### 4️⃣ Coin Change II \[Must Do]

**Pattern / Idea:** DP ways to make each amount

**Steps:**

1. dp\[0]=1
2. For each coin, update dp\[i] += dp\[i-coin]
3. Return dp\[amount]

**Code:**

```python
def change(amount, coins):
    dp=[0]*(amount+1)
    dp[0]=1
    for c in coins:
        for i in range(c, amount+1):
            dp[i]+=dp[i-c]
    return dp[amount]
```

**T.C.:** O(amount\*coins)
**S.C.:** O(amount)
**Hack:** “Build combinations per coin.”

---

### 5️⃣ Target Sum \[Must Do]

**Pattern / Idea:** Convert to subset sum problem

**Steps:**

1. sum(P) - sum(N) = target → subset sum = (sum+target)/2
2. Count subsets equal to (sum+target)/2
3. DP\[i] = ways to get sum i

**Code:**

```python
def findTargetSumWays(nums, target):
    total=sum(nums)
    if (total+target)%2!=0 or total<abs(target): return 0
    s=(total+target)//2
    dp=[0]*(s+1)
    dp[0]=1
    for num in nums:
        for i in range(s, num-1, -1):
            dp[i]+=dp[i-num]
    return dp[s]
```

**T.C.:** O(n\*s)
**S.C.:** O(s)
**Hack:** “Target → subset sum → DP.”

---

### 6️⃣ Interleaving String \[Must Do]

**Pattern / Idea:** 2-D DP: check if s3 formed by interleaving s1,s2

**Steps:**

1. DP\[i]\[j]=True if s3\[:i+j] formed by s1\[:i]+s2\[:j]
2. Recurrence: DP\[i]\[j] = (DP\[i-1]\[j] and s1\[i-1]==s3\[i+j-1]) or (DP\[i]\[j-1] and s2\[j-1]==s3\[i+j-1])

**Code:**

```python
def isInterleave(s1,s2,s3):
    if len(s1)+len(s2)!=len(s3): return False
    m,n=len(s1),len(s2)
    dp=[[False]*(n+1) for _ in range(m+1)]
    dp[0][0]=True
    for i in range(m+1):
        for j in range(n+1):
            if i>0: dp[i][j]|=dp[i-1][j] and s1[i-1]==s3[i+j-1]
            if j>0: dp[i][j]|=dp[i][j-1] and s2[j-1]==s3[i+j-1]
    return dp[m][n]
```

**T.C.:** O(m·n)
**S.C.:** O(m·n)
**Hack:** “Check prefixes → DP table.”

---

### 7️⃣ Longest Increasing Path in a Matrix \[Must Do]

**Pattern / Idea:** DFS + memoization. Move 4 directions increasing.

**Steps:**

1. For each cell, DFS to neighbors with higher value
2. Memoize max path length from each cell
3. Return max of all

**Code:**

```python
def longestIncreasingPath(matrix):
    if not matrix: return 0
    rows, cols = len(matrix), len(matrix[0])
    memo=[[0]*cols for _ in range(rows)]
    
    def dfs(r,c):
        if memo[r][c]: return memo[r][c]
        val=matrix[r][c]
        max_len=1
        for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
            nr,nc=r+dr,c+dc
            if 0<=nr<rows and 0<=nc<cols and matrix[nr][nc]>val:
                max_len=max(max_len,1+dfs(nr,nc))
        memo[r][c]=max_len
        return max_len
    
    return max(dfs(r,c) for r in range(rows) for c in range(cols))
```

**T.C.:** O(m·n)
**S.C.:** O(m·n)
**Hack:** “DFS + memo → max increasing path.”

---

### 8️⃣ Distinct Subsequences \[Must Do]

**Pattern / Idea:** 2-D DP: count ways s1→s2

**Steps:**

1. DP\[i]\[j] = number of ways s1\[:i] forms s2\[:j]
2. If chars match → DP\[i]\[j] = DP\[i-1]\[j-1] + DP\[i-1]\[j]
3. Else → DP\[i]\[j] = DP\[i-1]\[j]

**Code:**

```python
def numDistinct(s,t):
    m,n=len(s),len(t)
    dp=[[0]*(n+1) for _ in range(m+1)]
    for i in range(m+1): dp[i][0]=1
    for i in range(1,m+1):
        for j in range(1,n+1):
            if s[i-1]==t[j-1]:
                dp[i][j]=dp[i-1][j-1]+dp[i-1][j]
            else:
                dp[i][j]=dp[i-1][j]
    return dp[m][n]
```

**T.C.:** O(m·n)
**S.C.:** O(m·n)
**Hack:** “Char match → take+skip, else skip.”

---

### 9️⃣ Edit Distance \[Must Do]

**Pattern / Idea:** 2-D DP: min edits (insert, delete, replace)

**Steps:**

1. DP\[i]\[j]=min edits to convert word1\[:i]→word2\[:j]
2. Recurrence:

   * if same → DP\[i]\[j]=DP\[i-1]\[j-1]
   * else → 1+min(insert, delete, replace)

**Code:**

```python
def minDistance(word1, word2):
    m,n=len(word1),len(word2)
    dp=[[0]*(n+1) for _ in range(m+1)]
    for i in range(m+1): dp[i][0]=i
    for j in range(n+1): dp[0][j]=j
    for i in range(1,m+1):
        for j in range(1,n+1):
            if word1[i-1]==word2[j-1]:
                dp[i][j]=dp[i-1][j-1]
            else:
                dp[i][j]=1+min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    return dp[m][n]
```

**T.C.:** O(m·n)
**S.C.:** O(m·n)
**Hack:** “DP matrix → min insert/delete/replace.”

---

### 🔟 Burst Balloons \[Must Do]

**Pattern / Idea:** DP on subarrays, solve inside-out

**Steps:**

1. Extend array with 1 at both ends
2. DP\[i]\[j] = max coins bursting between i & j (exclusive)
3. Try every k in (i,j) as last burst → DP\[i]\[k]+DP\[k]\[j]+nums\[i]\*nums\[k]\*nums\[j]

**Code:**

```python
def maxCoins(nums):
    nums = [1]+nums+[1]
    n=len(nums)
    dp=[[0]*n for _ in range(n)]
    for length in range(2,n):
        for left in range(0,n-length):
            right=left+length
            for i in range(left+1,right):
                dp[left][right]=max(dp[left][right],
                                     dp[left][i]+dp[i][right]+nums[left]*nums[i]*nums[right])
    return dp[0][n-1]
```

**T.C.:** O(n³)
**S.C.:** O(n²)
**Hack:** “Burst last in subarray → max coins.”

---

### 1️⃣1️⃣ Regular Expression Matching \[Must Do]

**Pattern / Idea:** DP\[i]\[j]=s\[:i] matches p\[:j]

**Steps:**

1. DP\[0]\[0]=True
2. Handle `*` carefully: zero or multiple occurrence
3. Fill DP\[i]\[j] based on char match or `*`

**Code:**

```python
def isMatch(s,p):
    m,n=len(s),len(p)
    dp=[[False]*(n+1) for _ in range(m+1)]
    dp[0][0]=True
    for j in range(2,n+1):
        if p[j-1]=='*': dp[0][j]=dp[0][j-2]
    for i in range(1,m+1):
        for j in range(1,n+1):
            if p[j-1]==s[i-1] or p[j-1]=='.':
                dp[i][j]=dp[i-1][j-1]
            elif p[j-1]=='*':
                dp[i][j]=dp[i][j-2] or (dp[i-1][j] and (s[i-1]==p[j-2] or p[j-2]=='.'))
    return dp[m][n]
```

**T.C.:** O(m·n)
**S.C.:** O(m·n)
**Hack:** “\* → zero or many of prev char; . → match any.”

---


https://chatgpt.com/share/68cee332-85c0-8010-b144-7018d0a91a45

https://chatgpt.com/share/68cee355-c284-8010-9f4d-75b285d8c12c






---

# Computer Networks



---

## 1. **What is a Computer Network?**

* A **computer network** is a collection of devices (computers, servers, switches, routers, IoT devices) interconnected to share data/resources.
* Key goals:

  1. **Resource Sharing** → printers, files, storage.
  2. **Communication** → email, messaging, VoIP.
  3. **Scalability** → more devices/users can be added.
  4. **Reliability/Fault Tolerance** → alternate paths (redundancy).
  5. **Performance** → throughput, latency, jitter are key metrics.

### Metrics:

* **Bandwidth**: Maximum data transfer rate (bits/sec).
* **Throughput**: Actual achieved data rate (can be less than bandwidth).
* **Latency**: Time for data to travel from source to destination.
* **Jitter**: Variation in latency (important for real-time apps like VoIP).
* **Packet loss**: % of lost packets → affects QoS.

---

## 2. **Types of Networks**

* **PAN (Personal Area Network)** → Bluetooth, ZigBee.
* **LAN (Local Area Network)** → Ethernet/WiFi within office/home.
* **MAN (Metropolitan Area Network)** → City-wide, e.g., cable TV network.
* **WAN (Wide Area Network)** → Internet is the largest WAN.

### LAN Topologies:

1. **Bus** → all devices share one cable (cheap, single point of failure).
2. **Star** → central hub/switch connects devices (common in Ethernet).
3. **Ring** → each device connects to 2 others; token passing.
4. **Mesh** → every device connects to every other (high fault tolerance, costly).
5. **Hybrid** → combination.

---

## 3. **OSI Model (7 Layers)**

📌 **Interview trap** → Many candidates just memorize names, but interviewers push into *functions, protocols, and where issues like packet loss/error correction happen*.

1. **Physical Layer**

   * Raw transmission of bits (0s/1s).
   * Hardware: cables (twisted pair, coaxial, fiber), hubs, repeaters.
   * Concerns: voltage levels, bit rate, physical topology.
   * Protocols: Ethernet (physical part), DSL, WiFi physical standard (802.11).
   * Error **not detected** here (blind transmission).
   * Unit: **Bit**.

2. **Data Link Layer**

   * Ensures **error detection, correction, and framing**.
   * Divided into **LLC (Logical Link Control)** + **MAC (Medium Access Control)**.
   * Hardware: Switches, bridges.
   * Responsibilities:

     * Framing (convert bits → frames).
     * Error detection (CRC, checksum).
     * Flow control.
     * MAC addressing (48-bit unique address).
   * Protocols: Ethernet (data link part), PPP, ARP, HDLC.
   * Unit: **Frame**.

3. **Network Layer**

   * Handles **routing, logical addressing (IP)**, path determination.
   * Hardware: Routers.
   * Protocols: IPv4, IPv6, ICMP, IGMP.
   * Unit: **Packet**.
   * Key functions:

     * Routing algorithms: Distance Vector, Link State (Dijkstra, Bellman-Ford).
     * Fragmentation/Reassembly.
     * QoS in modern networks.

4. **Transport Layer**

   * Ensures **end-to-end communication**.
   * Responsibilities:

     * Multiplexing (ports).
     * Reliable delivery (ACK, retransmission in TCP).
     * Flow control (sliding window).
     * Error detection (checksums).
   * Protocols: TCP (reliable, connection-oriented), UDP (fast, connectionless).
   * Unit: **Segment** (TCP) / **Datagram** (UDP).

5. **Session Layer**

   * Establishes, maintains, and ends sessions between applications.
   * Functions: Authentication, authorization, session checkpoints.
   * Example: SSL/TLS handshakes.

6. **Presentation Layer**

   * Concerned with **syntax & semantics of data**.
   * Translates between application and network formats.
   * Functions: Compression, encryption, encoding.
   * Example: JPEG, MPEG, TLS encryption.

7. **Application Layer**

   * User-facing protocols.
   * Protocols: HTTP/HTTPS, FTP, SMTP, DNS, POP3, SNMP.
   * Unit: **Message**.

📌 **Mnemonic:** Please Do Not Throw Sausage Pizza Away.

---

## 4. **TCP/IP Model (4 Layers)**

* Practical model of the Internet.
* Maps to OSI:

| **TCP/IP Layer**    | **OSI Equivalent**                   | **Examples**         |
| ------------------- | ------------------------------------ | -------------------- |
| Application         | Application + Presentation + Session | HTTP, DNS, FTP, SMTP |
| Transport           | Transport                            | TCP, UDP             |
| Internet            | Network                              | IP, ICMP, ARP, IGMP  |
| Network Access/Link | Data Link + Physical                 | Ethernet, WiFi, PPP  |

---

## 5. **Encapsulation / Decapsulation**

* Data goes **down layers (encapsulation)** at sender, **up layers (decapsulation)** at receiver.
* Example (sending HTTP data):

  * Application: “GET request”
  * Transport: TCP adds header (port, seq no).
  * Network: IP adds header (IP address).
  * Data Link: MAC header added.
  * Physical: Sent as bits.

---

💡 **Interview Probing Angles on OSI/TCP:**

* Why TCP/IP has 4 layers while OSI has 7?
* Where exactly do encryption & compression belong?
* Why is error correction not at network layer? (Because that’s transport’s responsibility).
* Why UDP despite TCP existing? (low latency, streaming).
* Difference between hub, switch, router in terms of layers.

---





---

# 📘 Data Link Layer (DLL) — Deep Notes

---

## 1. **Role of DLL**

* Bridges the gap between **raw bit transmission (Physical Layer)** and **logical addressing/routing (Network Layer)**.
* Handles **framing, error detection/correction, flow control, MAC addressing**.
* Responsible for reliable **hop-to-hop** delivery (NOT end-to-end — that’s Transport).

📌 **Key Units:** **Frame** (not packet/segment/bit).

---

## 2. **Sub-layers**

1. **LLC (Logical Link Control)**

   * Provides interface to Network Layer.
   * Flow control, error checking.
   * Protocol: IEEE 802.2.

2. **MAC (Media Access Control)**

   * Controls how devices access the shared medium.
   * Adds **source & destination MAC addresses**.
   * Protocols: Ethernet (802.3), Wi-Fi MAC (802.11).

---

## 3. **Framing**

* Converts stream of bits into manageable **frames**.
* Methods:

  1. **Character count** → header stores frame length (problem: count corruption breaks all).
  2. **Byte stuffing** → special start/end characters, escape characters inside.
  3. **Bit stuffing** → use flag `01111110`; insert 0 after five consecutive 1s. Used in HDLC, PPP.

---

## 4. **Error Detection & Correction**

* **Noise & interference** → bits flip.
* DLL ensures corrupted frames are caught.

### Detection Methods:

* **Parity Bit** → simplest, 1-bit redundancy (weak).
* **Checksum** → sum of all words, take 1’s complement.
* **Cyclic Redundancy Check (CRC)** → MOST COMMON (used in Ethernet, PPP).

  * Treats frame as binary polynomial.
  * Divides by generator polynomial `G(x)`.
  * Remainder = CRC bits.
  * Receiver recomputes; mismatch = error.

### Correction Methods:

* **ARQ (Automatic Repeat reQuest)** → retransmit if error detected.

  * Stop-and-Wait ARQ.
  * Go-Back-N ARQ.
  * Selective Repeat ARQ.

📌 **Trap Q**: Why not always use Forward Error Correction (FEC)?
👉 FEC adds huge redundancy; better for noisy channels (satellite links), but wasteful in LAN.

---

## 5. **Flow Control**

Ensures sender does not overwhelm receiver.

1. **Stop-and-Wait** → send one frame, wait for ACK. Simple but inefficient.
2. **Sliding Window Protocols**:

   * **Go-Back-N** → if one frame lost, retransmit from that frame onward.
   * **Selective Repeat** → retransmit only the erroneous frame. More efficient, but complex.

---

## 6. **MAC Addressing**

* Each NIC has a unique **48-bit MAC address**.
* Format: `AA:BB:CC:DD:EE:FF` (Hexadecimal).
* First 24 bits = **OUI** (vendor ID).
* Last 24 bits = NIC-specific.

### MAC vs IP:

* **MAC** = physical identity (doesn’t change, unless spoofed).
* **IP** = logical identity, can change across networks.

---

## 7. **Medium Access Control (How devices share medium)**

1. **Static** → Pre-assigned (TDMA, FDMA).
2. **Dynamic** → Contention-based (Ethernet, Wi-Fi).

### Ethernet: CSMA/CD (Carrier Sense Multiple Access with Collision Detection)

* Used in **wired LANs**.
* Steps:

  1. Sense channel → if idle, send frame.
  2. If collision occurs → all nodes stop, send **jam signal**.
  3. Wait for random backoff (exponential).

📌 With modern **full-duplex switched Ethernet**, collisions are GONE, so CSMA/CD is legacy.

### Wi-Fi: CSMA/CA (Collision Avoidance)

* Wireless can’t detect collisions → instead it avoids them.
* Uses:

  * **RTS/CTS handshake**.
  * Backoff timers.

---

## 8. **Protocols & Standards**

* **Ethernet (802.3)** → most popular LAN protocol.
* **PPP (Point-to-Point Protocol)** → used in DSL, VPN tunneling.
* **HDLC (High-Level Data Link Control)** → WANs, uses bit stuffing.
* **VLAN (Virtual LANs)** → logically split LANs using tags in Ethernet frames (802.1Q).

---

## 9. **ARP & RARP**

* **ARP (Address Resolution Protocol)** → maps IP → MAC.

  * Example: To send packet to 192.168.1.5, sender broadcasts ARP request: “Who has this IP?”
  * Owner replies with MAC.
* **RARP** → reverse (MAC → IP). Obsolete, replaced by DHCP/BOOTP.

📌 **Interview trap**: Where does ARP belong?

* Works at **Data Link layer**, but interacts with **Network Layer** (so sometimes called a “layer 2.5” protocol).

---

## 10. **Devices Working at DLL**

* **Switch** → filters & forwards based on MAC.
* **Bridge** → connects two LAN segments.

Difference between **Switch vs Hub vs Router**:

* Hub → Physical layer (dumb, broadcasts everything).
* Switch → Data link layer (uses MAC tables).
* Router → Network layer (uses IP).

---

### 🔑 Interview Probing Angles ( -style)

* Why CRC is more powerful than checksum?
* What happens if ARP table is poisoned? (→ ARP spoofing attack).
* Can two devices have same MAC? (Yes if spoofed → causes conflict).
* Why CSMA/CD not in Wi-Fi? (wireless can’t detect collisions).
* What problem does VLAN solve? (segmentation, reduces broadcast domain).

---




---

# 📘 Subnetting — Deep Dive + Problems

---

## 1. **Subnetting Basics**

* IP address = **Network ID + Host ID**.
* **Subnet mask** decides how many bits are for network.
* **Formulae**:

  * Number of hosts = `2^(host bits) – 2`
    (–2 because network ID + broadcast not usable).
  * Number of subnets = `2^(borrowed bits)`.

---

## 2. **CIDR (Classless Inter-Domain Routing)**

Notation: `192.168.1.0/26` →

* `/26` means **26 bits network**, **6 bits host**.
* So → `2^6 – 2 = 62 hosts`.

---

## 3. **Step-by-Step Problem Solving**

### **Problem 1:**

How many subnets & hosts in `192.168.10.0/28`?

* IP = Class C (default mask = /24).
* Given mask = /28 → borrowed `28 – 24 = 4 bits`.
* Subnets = `2^4 = 16 subnets`.
* Hosts per subnet = `2^(32 – 28) – 2 = 2^4 – 2 = 14`.

✅ **Answer:** 16 subnets, 14 hosts each.

---

### **Problem 2:**

Company needs **100 hosts per subnet**. Which subnet mask?

* Hosts formula: `2^h – 2 ≥ 100`.
* `2^7 – 2 = 126`.
* So need 7 host bits → `/25` (since 32 – 7 = 25).

✅ **Answer:** Use `/25` mask. Each subnet = 126 hosts.

---

### **Problem 3:**

Given network `10.0.0.0/24`, divide into **4 equal subnets**.

* `/24` = 256 addresses total.
* Need 4 subnets → borrow 2 bits (since `2^2 = 4`).
* New mask = `/26`.
* Each subnet = `2^(6) – 2 = 62 hosts`.

Subnets:

* `10.0.0.0/26`
* `10.0.0.64/26`
* `10.0.0.128/26`
* `10.0.0.192/26`

---

### **Problem 4 (Interview-style):**

Can `172.16.0.0/20` support 500 hosts?

* Hosts available = `2^(32 – 20) – 2 = 2^12 – 2 = 4094`.
* Yes, way more than 500.

---

---

# 📘 Fragmentation — Deep Dive + Problems

---

## 1. **Fragmentation Basics**

* Happens when **packet > MTU**.
* Fields in IPv4 header:

  * **Identification** = same for all fragments.
  * **Fragment Offset** = position of fragment in multiples of 8 bytes.
  * **MF (More Fragments)** flag = 1 (if more follow), 0 (if last).

---

## 2. **Step-by-Step Problem Solving**

### **Problem 1:**

Packet size = 4000 bytes, MTU = 1500, header = 20 bytes.
How many fragments?

* Data per fragment = `1500 – 20 = 1480 bytes`.
* First 2 fragments: 1480 data each.
* Last fragment: 4000 – (1480 × 2) = 1040 data.

👉 Offsets (in 8-byte units):

* Frag 1: offset = 0, MF = 1.
* Frag 2: offset = 185 (1480/8), MF = 1.
* Frag 3: offset = 370, MF = 0.

✅ **Answer:** 3 fragments.

---

### **Problem 2 (Common MCQ):**

MTU = 600, header = 20, packet = 2400.

* Data per fragment = 580.
* Fragments:

  * 580, 580, 580, 580 (total 2320).
  * Last fragment = 80.
* BUT offset must be multiple of 8 → so last = 72, leaving 8 leftover in final fragment.

✅ **Answer:** 5 fragments (580, 580, 580, 580, 72+8).

---

### **Problem 3:**

If a packet has MF = 0 and offset = 0, what does it mean?

* No fragmentation occurred.

---

### **Problem 4 (Trick):**

Why fragmentation avoided in IPv6?

* IPv6 doesn’t allow routers to fragment.
* Only source host fragments (Path MTU discovery).
* Simplifies router processing.

---

---

# 📌 High-Yield Interview Qs (Subnetting + Fragmentation)

1. Given subnet mask, calculate **hosts**.
2. Given hosts needed, find **mask**.
3. Divide network into **N subnets**.
4. Fragmentation offset calculations.
5. Difference IPv4 vs IPv6 fragmentation.
6. Why do we subtract 2 in host calculation? (network & broadcast).
7. Max number of hosts in `/30` subnet? (2).

---



Perfect. Transport Layer is **heavily asked** in  /other SWE interviews, especially concepts like TCP reliability, congestion control, handshakes, and UDP differences. Let’s go **full deep dive**.

---

# 📘 Transport Layer (TL) — Deep Notes

---

## 1. **Role of Transport Layer**

* Ensures **end-to-end (host-to-host) communication**, unlike Network Layer (hop-to-hop).
* Provides **multiplexing/demultiplexing**, **reliability**, **flow control**, **congestion control**, **error detection**.
* **Unit of data = Segment** (TCP/UDP segment).

---

## 2. **Protocols**

1. **TCP (Transmission Control Protocol)**

   * Connection-oriented, reliable, byte-stream.
   * Guarantees:

     * **Ordered delivery**
     * **No loss** (retransmission)
     * **No duplication**
     * **Flow control**
   * Heavyweight → more overhead.

2. **UDP (User Datagram Protocol)**

   * Connectionless, unreliable, message-oriented.
   * Lightweight → faster, used in **DNS, VoIP, streaming**.
   * No flow/congestion control, no guarantee of delivery.

---

## 3. **TCP Segment Structure**

| Field            | Size     | Description                                |
| ---------------- | -------- | ------------------------------------------ |
| Source Port      | 16b      | Sender port                                |
| Destination Port | 16b      | Receiver port                              |
| Sequence Number  | 32b      | First byte of segment data                 |
| Ack Number       | 32b      | Next expected byte                         |
| Data Offset      | 4b       | Header length                              |
| Reserved         | 3b       | 0                                          |
| Flags            | 9b       | SYN, ACK, FIN, RST, PSH, URG, ECE, CWR, NS |
| Window Size      | 16b      | Flow control                               |
| Checksum         | 16b      | Error detection                            |
| Urgent Pointer   | 16b      | Optional                                   |
| Options          | variable | Optional (e.g., MSS)                       |
| Data             | variable | Payload                                    |

---

## 4. **3-Way Handshake (TCP Connection Establishment)**

1. **SYN** → Client sends segment with SYN = 1, Seq = x
2. **SYN-ACK** → Server responds, Seq = y, Ack = x+1
3. **ACK** → Client sends Ack = y+1

✅ Guarantees:

* Connection established
* Initial sequence numbers synchronized

---

## 5. **Connection Termination**

* 4-way handshake: FIN/ACK from both sides
* States: FIN\_WAIT, TIME\_WAIT, CLOSE\_WAIT

📌 ** _ Trap**: Why TIME\_WAIT?

* Ensures all delayed segments are discarded before new connections reuse same ports.

---

## 6. **Flow Control**

* TCP uses **Sliding Window Protocol** (window = bytes sender can send without ACK).
* Prevents **receiver overflow**.
* Receiver advertises **window size** → sender adapts.

---

## 7. **Congestion Control**

* Prevents **network overload**.
* Mechanisms:

  1. **Slow Start** → CWND starts at 1 MSS, doubles every RTT until threshold.
  2. **Congestion Avoidance** → Linear increase.
  3. **Fast Retransmit** → retransmit after 3 duplicate ACKs.
  4. **Fast Recovery** → reduces CWND instead of restarting slow start.

📌 Variables:

* **CWND** = congestion window
* **SSTHRESH** = threshold between slow start & congestion avoidance

---

## 8. **Reliable Data Transfer**

* TCP ensures:

  * ACK-based retransmission
  * Sequence numbers → order
  * Checksums → error detection
* Techniques: **Stop-and-Wait**, **Go-Back-N**, **Selective Repeat** (conceptually, TCP = sliding window variant).

---

## 9. **UDP Segment**

* Simple header:

  * Src Port, Dest Port, Length, Checksum, Data
* No connection setup, no ACKs, no sequencing
* Use-case: **real-time streaming**, **DNS queries**, **VoIP**

---

## 10. **TCP vs UDP Comparison**

| Feature            | TCP    | UDP  |
| ------------------ | ------ | ---- |
| Connection         | Yes    | No   |
| Reliability        | Yes    | No   |
| Flow Control       | Yes    | No   |
| Congestion Control | Yes    | No   |
| Ordering           | Yes    | No   |
| Speed              | Slower | Fast |
| Overhead           | High   | Low  |

---

## 11. **Key Interview Traps / Qs**

* Explain **3-way handshake + seq/ack numbers**
* Difference **flow control vs congestion control**
* Why **TCP has retransmission** but UDP doesn’t
* Difference between **reliable byte-stream vs message-oriented**
* Sliding window → difference between sender window & receiver window
* Why **TIME\_WAIT**? → prevents old segments from interfering
* Which protocols use UDP? Why? → multimedia, DNS, DHCP

---



---

# 📘 Application Layer + Security — Deep Dive Notes

---

## 1. **Application Layer (Layer 7)**

* Provides **end-user services**: email, web, file transfer, etc.
* Protocols here are **host-to-host, process-to-process**, running over Transport Layer (TCP/UDP).

### Key Protocols:

| Protocol | Port  | Transport | Purpose                                  |
| -------- | ----- | --------- | ---------------------------------------- |
| HTTP     | 80    | TCP       | Web browsing                             |
| HTTPS    | 443   | TCP       | Secure web browsing (HTTP + TLS)         |
| FTP      | 20/21 | TCP       | File transfer                            |
| SFTP     | 22    | TCP       | Secure FTP over SSH                      |
| SMTP     | 25    | TCP       | Email sending                            |
| POP3     | 110   | TCP       | Email retrieval                          |
| IMAP     | 143   | TCP       | Email retrieval (server-side management) |
| DNS      | 53    | UDP/TCP   | Domain name resolution                   |
| DHCP     | 67/68 | UDP       | IP assignment                            |
| Telnet   | 23    | TCP       | Remote terminal (insecure)               |
| SSH      | 22    | TCP       | Secure remote login                      |
| SNMP     | 161   | UDP       | Network monitoring                       |
| NTP      | 123   | UDP       | Time sync                                |

---

## 2. **HTTP & HTTPS**

* **HTTP**: stateless, request/response model, runs over TCP.

  * Methods: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`.
  * Status codes: `2xx = success`, `3xx = redirect`, `4xx = client error`, `5xx = server error`.
* **HTTPS**: HTTP over TLS/SSL.

  * Provides:

    * **Encryption** (confidentiality)
    * **Integrity** (detect tampering)
    * **Authentication** (verify server identity)
  * **TLS Handshake**:

    1. ClientHello (cipher suites)
    2. ServerHello + Certificate
    3. Key exchange
    4. Session keys established

---

## 3. **DNS**

* Maps domain names → IP addresses.
* Types:

  * **A record** → IPv4
  * **AAAA record** → IPv6
  * **CNAME** → canonical name
  * **MX** → mail servers
* Uses **UDP mostly**, TCP if response > 512 bytes.

---

## 4. **FTP vs SFTP**

| Feature        | FTP               | SFTP                        |
| -------------- | ----------------- | --------------------------- |
| Transport      | TCP               | TCP over SSH                |
| Security       | None (plaintext)  | Encrypted                   |
| Authentication | Username/password | Username/password or keys   |
| Use-case       | Old file transfer | Modern secure file transfer |

---

## 5. **Email Protocols**

* **SMTP**: send mail (outgoing), TCP/25
* **POP3**: retrieve mail (download), TCP/110
* **IMAP**: retrieve mail (sync, server-side), TCP/143

---

## 6. **Remote Access**

* **Telnet**: insecure (plaintext), TCP/23
* **SSH**: secure, encrypted, TCP/22

  * Public/private key authentication possible
  * Provides secure shell, file transfer

---

## 7. **Network Security Essentials**

### 7.1 **Firewalls**

* **Purpose:** Control incoming/outgoing traffic based on rules.
* Types:

  1. **Packet Filtering** → allow/block based on IP, port, protocol
  2. **Stateful Inspection** → track connection state (TCP handshake)
  3. **Proxy Firewall** → acts as intermediary, inspects content
  4. **Next-Gen Firewall (NGFW)** → deep packet inspection, intrusion prevention, application awareness

** _ Trap Qs:**

* Difference between packet filtering vs stateful?
* Why use NGFW over traditional firewall?

---

### 7.2 **VPN (Virtual Private Network)**

* Creates **encrypted tunnel** over public Internet.
* Types:

  * **Site-to-Site** → connects networks
  * **Remote Access** → user connects to network
* Protocols:

  * **IPSec** → IP-layer encryption
  * **SSL VPN** → application-layer (browser-based)

---

### 7.3 **TLS / SSL**

* Provides **encryption + integrity + authentication**.
* Uses **Public Key Cryptography** for key exchange, then **symmetric encryption** for data.
* Handshake involves:

  1. Agree cipher suite
  2. Server certificate validation
  3. Exchange session keys
  4. Secure communication

---

### 7.4 **IDS / IPS**

* **IDS (Intrusion Detection System)** → detects malicious activity, **alerts admin**, passive.
* **IPS (Intrusion Prevention System)** → detects + **blocks/mitigates**, active.
* Types:

  * **Signature-based** → known attacks
  * **Anomaly-based** → unusual traffic patterns

---

### 7.5 **Common Security Mechanisms**

* **Authentication** → verify identity (passwords, tokens, certificates)
* **Authorization** → access control
* **Encryption** → confidentiality (symmetric/asymmetric)
* **Digital Signatures** → integrity + authentication
* **Hashing** → integrity check (SHA-256, MD5)
* **Firewall rules + ACLs** → traffic filtering

---

### 7.6 **Practical  _ Q Examples**

1. Difference HTTP vs HTTPS
2. Explain SSL/TLS handshake
3. DNS query flow → iterative vs recursive
4. Email flow → SMTP to MX → POP3/IMAP retrieval
5. VPN types and use-cases
6. Firewall types + stateful vs stateless
7. IDS vs IPS difference
8. Why public key used only in handshake, symmetric for bulk?

---

---

# 📘 Firewalls — Complete Deep Dive

---

## 1. **Definition**

A **firewall** is a **network security device** (hardware or software) that **monitors and controls incoming/outgoing traffic** based on **security rules**.

**Purpose:**

* Prevent unauthorized access
* Protect internal networks from attacks
* Enforce security policies

---

## 2. **Why Firewalls Are Used**

1. **Access control** → Block unwanted IPs, ports, or protocols
2. **Segmentation** → Protect sensitive subnets
3. **Threat prevention** → Stop attacks before they reach endpoints
4. **Monitoring & logging** → Record traffic for audits
5. **Policy enforcement** → Allow only approved apps or traffic

---

## 3. **Firewall Types**

### **3.1 Packet-Filtering Firewall**

* Works at **Network Layer (Layer 3)**.
* Checks each packet’s **IP address, port, protocol**.
* **Pros:** Fast, simple
* **Cons:** Cannot inspect packet payload (content), no session tracking
* **Use:** Basic access control

** _ Trap Qs:** Difference between stateful and packet-filtering?

---

### **3.2 Stateful Inspection Firewall**

* Tracks **connection state** (TCP handshake) at **Transport Layer (Layer 4)**.
* Allows packets only if they **belong to an established session**.
* **Pros:** Safer than packet-filtering, tracks sessions
* **Cons:** More memory/processing required
* **Use:** Modern corporate networks

---

### **3.3 Proxy Firewall (Application-Level Firewall)**

* Acts as **intermediary between client and server**.
* Can **inspect application data** (HTTP, FTP).
* **Pros:** Deep packet inspection, content filtering, hides internal network
* **Cons:** Slower (all traffic passes through proxy)
* **Use:** Sensitive environments needing content control

---

### **3.4 Next-Generation Firewall (NGFW)**

* Combines:

  * Stateful inspection
  * Deep Packet Inspection (DPI)
  * Intrusion Prevention System (IPS)
  * Application awareness/control
* Can detect **malware, exploits, and advanced attacks**.
* **Real-world use:** Cisco Firepower, Palo Alto, Fortinet

---

### **3.5 Host-Based Firewall**

* Runs on **individual devices** (Windows Firewall, iptables, pfSense).
* Protects a single host, often used with endpoint protection.

---

### **3.6 Cloud Firewall**

* For **cloud environments** (AWS Security Groups, Azure NSG, GCP Firewall).
* Protects virtual machines and cloud resources.
* Can be **stateful or stateless**, rules applied dynamically.

---

## 4. **Firewall Deployment Modes**

1. **Network Firewall** → Protects entire network, sits at boundary (perimeter firewall)
2. **Host Firewall** → Protects individual machines
3. **Virtual/Cloud Firewall** → Protects cloud resources
4. **Hybrid** → Combination of above

---

## 5. **Common  _ Interview Questions on Firewalls**

* Types of firewalls and differences
* Which firewall inspects **packet payload**? (Answer: Proxy / NGFW)
* Difference **stateful vs stateless**
* Why NGFW over traditional firewalls?
* Real-world firewall products and deployment:

  * Cisco ASA / Firepower → NGFW, enterprise
  * Palo Alto → NGFW, app-aware
  * Fortinet FortiGate → multi-layer protection
  * iptables / ufw → Linux host firewall
  * Windows Firewall → host-based
* How firewall works with NAT?
* Firewall + IDS/IPS differences

---

## 6. **Summary Table**

| Firewall Type    | Layer   | Inspection       | Pros              | Cons                   | Example                    |
| ---------------- | ------- | ---------------- | ----------------- | ---------------------- | -------------------------- |
| Packet Filtering | 3       | Header only      | Fast, simple      | No payload, no session | Cisco ACLs                 |
| Stateful         | 4       | Tracks session   | Safer than packet | Memory-intensive       | Cisco ASA                  |
| Proxy / App FW   | 7       | Full payload     | Deep inspection   | Slower                 | Squid Proxy                |
| NGFW             | 3-7     | Full + IPS + App | Advanced security | Costly                 | Palo Alto, Fortinet        |
| Host-Based       | Host    | Header + payload | Local protection  | Device-only            | Windows Firewall, iptables |
| Cloud            | Virtual | Depends          | Protects cloud    | Policy config needed   | AWS Security Group         |

---



---

# 📘 IDS / IPS, VPN, and Encryption — Deep Dive Notes

---

## 1. **IDS (Intrusion Detection System)**

* **Purpose:** Detects **malicious activity** or policy violations on a network.
* **Function:** Monitors traffic, logs suspicious activity, alerts admin.
* **Type:** Passive (doesn’t block traffic).

### **IDS Types**

1. **Signature-based**

   * Compares traffic to known attack patterns.
   * Pros: Accurate for known attacks
   * Cons: Cannot detect new/zero-day attacks

2. **Anomaly-based**

   * Detects traffic deviating from normal behavior (baseline).
   * Pros: Can detect new attacks
   * Cons: False positives are common

** _ Trap Qs:** Difference between IDS and IPS?

---

## 2. **IPS (Intrusion Prevention System)**

* **Purpose:** Detects **and blocks** malicious activity.
* Active system → sits **inline with traffic**.
* Types similar to IDS: signature-based, anomaly-based.

### **Key Differences IDS vs IPS**

| Feature         | IDS                  | IPS                            |
| --------------- | -------------------- | ------------------------------ |
| Traffic Action  | Alert                | Block / Drop                   |
| Position        | Passive / Monitoring | Inline / Active                |
| False Positives | Only logs            | Can affect traffic             |
| Example         | Snort IDS            | Snort IPS, Cisco Firepower IPS |

---

## 3. **VPN (Virtual Private Network)**

* **Purpose:** Provides **secure, encrypted connection** over public networks.
* Creates a **tunnel** between client and network.

### **Types of VPN**

1. **Site-to-Site VPN**

   * Connects two networks over the internet.
   * Example: Branch office → HQ network
2. **Remote Access VPN**

   * Connects an individual client to a network
   * Example: Employee working from home

### **Protocols**

| Protocol    | Layer | Encryption | Use-case                       |
| ----------- | ----- | ---------- | ------------------------------ |
| PPTP        | 2/3   | Weak       | Legacy / fast, not secure      |
| L2TP/IPSec  | 2/3   | Strong     | Site-to-site & remote access   |
| SSL/TLS VPN | 4/7   | Strong     | Browser-based, secure web apps |
| OpenVPN     | 3/4   | Strong     | Open-source, flexible          |

** _ Trap Qs:**

* Difference SSL VPN vs IPSec VPN
* Why VPN encrypts traffic but firewall filters?

---

## 4. **Encryption / TLS / SSL**

* **Purpose:** Ensure **confidentiality, integrity, and authenticity**.

### **SSL/TLS Basics**

* SSL = predecessor of TLS (obsolete, use TLS today).
* TLS provides:

  1. **Encryption** → hides data from eavesdroppers
  2. **Integrity** → detects tampering (hashing, MAC)
  3. **Authentication** → server identity verified via certificates

### **TLS Handshake Process**

1. **ClientHello** → cipher suites, random number
2. **ServerHello** → chosen cipher, certificate (public key)
3. **Key Exchange** → Diffie-Hellman / RSA
4. **Session Key Established** → symmetric encryption for data
5. **Secure communication begins**

** _ Trap Qs:**

* Why use asymmetric encryption only in handshake? → Slow, only for key exchange
* Symmetric encryption for bulk data → fast, secure
* Certificate authority role → ensures server authenticity

---

## 5. **Hashing & Digital Signatures**

* **Hashing:** Converts data → fixed-length digest (SHA-256, MD5).
* **Purpose:** Verify **integrity**.
* **Digital Signature:** Hash + asymmetric encryption → verify **integrity + authenticity**.

**Example Interview Q:**

* Explain how HTTPS ensures confidentiality, integrity, and authentication

---

## 6. **Security Scenarios /  _-Style Questions**

1. You see a packet with SYN flood → which system blocks it? → IPS
2. Employee wants to connect from home → which protocol to use? → SSL VPN or L2TP/IPSec
3. Explain HTTPS handshake step-by-step
4. Difference IDS vs IPS, TCP vs UDP in attacks
5. How firewall + VPN + IPS + TLS work together to secure network

---

## ✅ Summary Table

| Concept           | Key Points                            |  _ Interview Traps                              |
| ----------------- | ------------------------------------- | ------------------------------------------------ |
| IDS               | Detects & alerts, signature/anomaly   | Passive, doesn’t block                           |
| IPS               | Detects & blocks                      | Inline, can disrupt traffic                      |
| VPN               | Encrypt tunnel, site-to-site / remote | SSL vs IPSec differences                         |
| TLS/SSL           | Handshake, encryption, authentication | Asymmetric only in handshake, symmetric for bulk |
| Hashing           | Integrity                             | SHA-256 preferred over MD5                       |
| Digital Signature | Integrity + authenticity              | Uses hash + asymmetric key                       |

---



---

# 📘 Advanced Threats & Security Tools — Deep Dive

---

## 1. **DDoS Attacks (Distributed Denial of Service)**

* **Definition:** Multiple compromised machines flood a target system/network with traffic, overwhelming resources → service downtime.
* **Example:** Attackers use a **botnet** to send millions of HTTP requests to a website.

### Types of DDoS:

1. **Volume-based attacks**

   * Flood the bandwidth
   * Measured in **bps (bits per second)**
   * Example: UDP flood, ICMP flood
2. **Protocol attacks**

   * Exploit server/network resources
   * Measured in **pps (packets per second)**
   * Example: SYN flood, Ping of Death
3. **Application layer attacks**

   * Target web applications, exhausting resources
   * Example: HTTP GET/POST floods

**SYN Flood (specific protocol attack)**:

* Exploits TCP three-way handshake:

  1. Client → Server: SYN
  2. Server → Client: SYN-ACK
  3. Client → Server: ACK
* Attacker **never sends final ACK**, leaving half-open connections → server resources exhausted.
* Mitigation: **SYN cookies, firewalls, rate-limiting**

---

## 2. **Man-in-the-Middle (MITM) Attack**

* **Definition:** Attacker secretly intercepts/relays communication between two parties.
* **Goal:** Steal information, inject malicious data, or impersonate one party.

### Common MITM types:

1. **ARP Spoofing** – redirect LAN traffic to attacker
2. **DNS Spoofing** – redirect users to malicious websites
3. **HTTPS stripping** – downgrade HTTPS to HTTP

**Mitigation:**

* Use **TLS/HTTPS**
* Certificates validation
* VPNs (encrypt traffic end-to-end)
* HSTS (HTTP Strict Transport Security)

** _ Trap Q:** Explain how MITM can be prevented with TLS + certificates.

---

## 3. **Phishing Attacks / Social Engineering**

* **Phishing:** Fake emails/websites trick users into revealing credentials.
* **Social Engineering:** Manipulating humans to bypass security (phone calls, emails, in-person).

**Real-world  relevance:**

* Can be asked as “How would you prevent phishing in a corporate network?”
* Mitigation:

  * Employee training
  * Multi-factor authentication (MFA)
  * Anti-phishing tools & email filters

---

## 4. **Honeypots**

* **Definition:** Decoy system designed to attract attackers.
* Purpose:

  * Detect intrusions
  * Study attacker techniques
  * Divert attacks from real systems

**Types:**

* Low-interaction → simulates some services, minimal risk
* High-interaction → full system, detailed attacker study, higher risk

---

## 5. **SIEM (Security Information and Event Management)**

* **Definition:** Centralized platform that collects, analyzes, and alerts on security events.
* **Functions:**

  * Log aggregation (firewalls, servers, applications)
  * Threat detection
  * Real-time alerts
  * Compliance reporting

**Popular Tools:** Splunk,  _ QRadar, ArcSight

**Trap Q:** Explain how SIEM integrates firewall, IDS/IPS logs for threat detection.

---

## ✅ Key Takeaways for  Interviews:

| Threat/Tool                 | Purpose                      | Mitigation / Tool Example                 |
| --------------------------- | ---------------------------- | ----------------------------------------- |
| DDoS                        | Overwhelm server/network     | Rate limiting, firewalls, cloud scrubbing |
| SYN Flood                   | Exploit TCP handshake        | SYN cookies, firewalls                    |
| MITM                        | Intercept communication      | TLS/HTTPS, VPNs, certificate validation   |
| Phishing/Social Engineering | Steal credentials            | MFA, training, filters                    |
| Honeypot                    | Detect & study attackers     | Decoy systems, low/high interaction       |
| SIEM                        | Centralized threat detection | Splunk,   QRadar, log analysis          |

---


---

# Other subjects revision:


[C Programming Revision](https://www.geeksforgeeks.org/c/c-language-introduction/)

[DBMS Revision](https://takeuforward.org/dbms/most-asked-dbms-interview-questions)

[Operating Systems](https://takeuforward.org/operating-system/most-asked-operating-system-interview-questions)

---